<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LiveFish Edge</title>
  <link rel="icon" href="data:,">
  <script src="https://cdn.plot.ly/plotly-2.34.0.min.js"></script>

  <!-- netcdfjs UMD (NetCDF v3/classic only) -->
  <script src="https://cdn.jsdelivr.net/npm/netcdfjs@0.7.0/dist/netcdfjs.min.js"></script>
  <script>
    // netcdfjs UMD may expose NetCDFReader as window.NetCDFReader or window.netcdfjs.NetCDFReader
    window.NetCDFReader = window.NetCDFReader || (window.netcdfjs && window.netcdfjs.NetCDFReader) || null;
  </script>

  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #050b10;
      color: #e0e6ee;
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      overflow: auto;
    }

    #controls {
      position: sticky;
      top: 0;
      z-index: 50;
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 8px 12px;
      background: rgba(5, 11, 16, 0.92);
      border-bottom: 1px solid #1b2836;
      backdrop-filter: blur(6px);
    }

    #var-select {
      background: #0c1723;
      color: #e0e6ee;
      border: 1px solid #273649;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 18px;
      font-weight: 650;
    }

    #timeline {
      flex: 1;
      display: flex;
      gap: 8px;
      align-items: center;
      min-width: 360px;
    }

    button {
      background: #0c1723;
      color: #e0e6ee;
      border: 1px solid #273649;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 14px;
      cursor: pointer;
    }
    button:disabled { opacity: 0.45; cursor: default; }

    #frame-slider { flex: 1; }

    #frame-label {
      min-width: 190px;
      text-align: right;
      font-size: 18px;
      font-weight: 650;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    #plot-wrap {
      position: relative;
      width: 100%;
      overflow: auto;
    }

    #plot {
      width: 100%;
      height: calc(100vh - 56px - 56px);
      min-height: 860px;
    }

    #ranges {
      position: sticky;
      bottom: 0;
      z-index: 40;
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 8px 12px;
      background: rgba(5, 11, 16, 0.92);
      border-top: 1px solid #1b2836;
      backdrop-filter: blur(6px);
      font-size: 13px;
      flex-wrap: wrap;
    }

    .range-block {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 6px 8px;
      border: 1px solid #1b2836;
      border-radius: 8px;
      background: rgba(12, 23, 35, 0.65);
    }

    .range-block .name {
      font-weight: 700;
      margin-right: 4px;
    }

    input[type="number"] {
      width: 92px;
      background: #0c1723;
      color: #e0e6ee;
      border: 1px solid #273649;
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 13px;
    }

    /* Cursor info inside plot, upper-right, avoid colorbar */
    #readout {
      position: fixed;
      top: 10px;
      right: 110px;
      z-index: 60;
      padding: 6px 8px;
      background: rgba(255,255,255,0.55);
      color: #000;
      border: 1px solid rgba(0,0,0,0.12);
      border-radius: 8px;
      font-variant-numeric: tabular-nums;
      pointer-events: none;
      white-space: nowrap;
      min-width: 170px;
      text-align: right;
    }

    /* Modebar upper-left */
    #plot .modebar {
      left: 8px !important;
      right: auto !important;
      top: 8px !important;
    }
  
    /* mobile readout */
    @media (max-width: 760px) {
      #readout { right: 12px; font-size: 11px; padding: 3px 6px; }
      .modebar { top: 116px !important; left: 8px !important; }
    }
    /* keep Plotly modebar visible while scrolling */
    .modebar { position: fixed !important; top: 58px !important; left: 10px !important; z-index: 9999 !important; }
</style>
</head>

<body>
  <div id="controls">
    <select id="var-select">
      <option value="chl">Chlorophyll</option>
      <option value="sst">Temperature</option>
      <option value="uv">Currents</option>
      <option value="bath">Bathymetry</option>
    </select>

    <div id="timeline">
      <button id="prev-btn">&#9664;</button>
      <button id="play-btn">Play</button>
      <button id="next-btn">&#9654;</button>
      <input id="frame-slider" type="range" min="0" max="0" step="1" value="0" />
      <span id="frame-label"></span>
    </div>
  </div>

  <div id="plot-wrap">
    <div id="readout"></div>
    <div id="plot"></div>
  </div>

  <div id="ranges">
    <div class="range-block">
      <span class="name" id="range-title">Range</span>
      <span>vmin</span><input id="vmin-input" type="number" step="any" />
      <span>vmax</span><input id="vmax-input" type="number" step="any" />
      <button id="apply-range">Apply</button>
      <button id="reset-range">Reset</button>
    </div>
</div>

<script>
/* ========================= CONFIG ========================= */
const REGION_ID = "mbh";

const VAR_LABELS = { chl: "Chlorophyll", sst: "Temperature", uv: "Currents", bath: "Bathymetry" };

const VAR_TO_GRID = {
  chl: "viirs_chl_750_grid.json",
  sst: "goes_sst_1000_grid.json",
  uv:  "uv_12500_grid.json",
  bath: null
};

// Bathymetry (NetCDF3 classic; GEBCO subset)
const BATHY_NC_URL = `data/${REGION_ID}/gebco_bath_20251208/gebco_2025_n28.5_s24.5_w-79.0_e-75.0.nc`;


const INDEX_CANDIDATES = [
  "index.json",
  "data/index.json",
  `data/${REGION_ID}/index.json`
];

const DEFAULT_RANGES = {
  chl:  { vmin: 0.01, vmax: 10.0, unit: "mg/m³" }, // linear inputs; displayed as log10
  sst:  { vmin: 23.0, vmax: 28.0, unit: "°C" },
  uv:   { vmin: 0.0,  vmax: 1.0,  unit: "m" },    // Sea surface height (adt). If missing, we use speed as placeholder.
  bath: { vmin: -6000, vmax: 500, unit: "m" }
};

let userRanges = {
  chl:  { ...DEFAULT_RANGES.chl },
  sst:  { ...DEFAULT_RANGES.sst },
  uv:   { ...DEFAULT_RANGES.uv },
  bath: { ...DEFAULT_RANGES.bath }
};

const CHL_ALGAE = [
  [0.00, "#081d38"],
  [0.10, "#1d4f91"],
  [0.22, "#00a6ca"],
  [0.36, "#00d17f"],
  [0.52, "#a3f700"],
  [0.70, "#ffe600"],
  [0.86, "#ff7a00"],
  [1.00, "#b30000"]
];

// Per-variable color config (Plotly colorscales)
// NOTE: SST must be blue=cold and red=warm -> use RdBu_r with reversescale=false.
const COLOR_CONFIG = {
  chl:  { colorscale: CHL_ALGAE, reversescale: false },
  sst:  { colorscale: "RdBu_r",  reversescale: false },
  uv:   { colorscale: "RdBu_r",  reversescale: false }, // background under currents arrows (adt or speed placeholder)
  bath: { colorscale: "Earth",   reversescale: false }
};


const CHL_TICKS_LINEAR = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10];
const CHL_TICKVALS = CHL_TICKS_LINEAR.map(v => Math.log10(v));
const CHL_TICKTEXT = CHL_TICKS_LINEAR.map(v => (v===0.01||v===0.1||v===1||v===10) ? String(v) : "");

/* Currents arrow styling (VISIBLE heads) */
const CURRENT_ARROW_STEP_MAXPTS = 50 * 50;
const CURRENT_ARROW_SCALE = 1;
const CURRENT_HEAD_SIZE = 0.2;
const CURRENT_LINE_W = 1;

/* ========================= STATE ========================= */
let framesByVar = { chl: [], sst: [], uv: [] };
let frameTimesByVar = { chl: [], sst: [], uv: [] ,
    bath: [null]
  }; // epoch ms for closest-time match
let currentVar = "chl";
let currentFrameIdx = 0;
let playing = false;
let playTimer = null;

const gridCache = {};
let _readoutHooked = false;

let viewState = { hasRange:false, xRange:null, yRange:null, autorange:true };

/* ========================= DOM ========================= */
const plotDiv   = document.getElementById("plot");
const varSelect = document.getElementById("var-select");
const slider    = document.getElementById("frame-slider");
const frameLbl  = document.getElementById("frame-label");
const playBtn   = document.getElementById("play-btn");
const prevBtn   = document.getElementById("prev-btn");
const nextBtn   = document.getElementById("next-btn");
const readoutDiv = document.getElementById("readout");

const rangeTitle = document.getElementById("range-title");
const vminInput = document.getElementById("vmin-input");
const vmaxInput = document.getElementById("vmax-input");
const applyBtn = document.getElementById("apply-range");
const resetBtn = document.getElementById("reset-range");

function setReadout(txt) { readoutDiv.textContent = txt || ""; }

/* ========================= TIME PARSERS ========================= */
function parseChlUtcFromName(filename) {
  const m = filename.match(/_(\d{4})(\d{3})\.(\d{4})_/);
  if (!m) return null;
  const year = Number(m[1]);
  const jjj  = Number(m[2]);
  const hhmm = m[3];
  const hh = Number(hhmm.slice(0, 2));
  const mm = Number(hhmm.slice(2, 4));
  const d0 = new Date(Date.UTC(year, 0, 1, 0, 0, 0));
  return new Date(d0.getTime() + (jjj - 1) * 86400e3 + hh * 3600e3 + mm * 60e3);
}
function parseSstUtcFromName(filename) {
  const m = filename.match(/sst_.*?_(\d{4})(\d{3})_(\d{8})_(\d{2})_/);
  if (!m) return null;
  const year = Number(m[1]);
  const jjj  = Number(m[2]);
  const hh   = Number(m[4]);
  const d0 = new Date(Date.UTC(year, 0, 1, 0, 0, 0));
  return new Date(d0.getTime() + (jjj - 1) * 86400e3 + hh * 3600e3);
}
function parseUvDateFromName(filename) {
  const m = filename.match(/_(\d{8})_/);
  if (!m) return null;
  const y = Number(m[1].slice(0, 4));
  const mo = Number(m[1].slice(4, 6)) - 1;
  const d = Number(m[1].slice(6, 8));
  return new Date(Date.UTC(y, mo, d));
}
function fmtLocalDateTime(dt) {
  return dt.toLocaleString(undefined, {
    year: "numeric", month: "2-digit", day: "2-digit",
    hour: "2-digit", minute: "2-digit", hour12: false
  });
}
function fmtLocalDate(dt) {
  return dt.toLocaleDateString(undefined, { year:"numeric", month:"2-digit", day:"2-digit" });
}
function timeOnlyLabel(varKey, frameMeta) {
  const path = frameMeta.json_path || frameMeta.path || frameMeta.file || "";
  const filename = String(path).split("/").pop() || "";
  if (varKey === "chl") { const dt = parseChlUtcFromName(filename); return dt ? fmtLocalDateTime(dt) : ""; }
  if (varKey === "sst") { const dt = parseSstUtcFromName(filename); return dt ? fmtLocalDateTime(dt) : ""; }
  if (varKey === "uv")  { const dt = parseUvDateFromName(filename);  return dt ? fmtLocalDate(dt) : ""; }
  return "";
}
function epochMsForFrame(varKey, frameMeta) {
  const path = frameMeta.json_path || frameMeta.path || frameMeta.file || "";
  const filename = String(path).split("/").pop() || "";
  let dt = null;
  if (varKey === "chl") dt = parseChlUtcFromName(filename);
  if (varKey === "sst") dt = parseSstUtcFromName(filename);
  if (varKey === "uv")  dt = parseUvDateFromName(filename); // date-only
  return dt ? dt.getTime() : null;
}

/* ========================= HELPERS ========================= */
function is2D(a) { return Array.isArray(a) && a.length > 0 && Array.isArray(a[0]) && a[0].length > 0; }
function framePathOf(f) { return String(f?.json_path || f?.path || f?.file || f?.url || f?.json || ""); }
function frameFilenameOf(f) { const p = framePathOf(f); return p.split("/").pop() || p; }
function filterFramesForVar(varKey, frames) {
  const out = [];
  for (const f of (frames || [])) {
    const fn = frameFilenameOf(f).toLowerCase();
    if (!fn.endsWith(".json")) continue;
    if (fn.includes("grid")) continue;
    if (varKey === "chl" && !fn.includes("_chl_")) continue;
    if (varKey === "sst" && !fn.startsWith("sst_")) continue;
    if (varKey === "uv"  && !fn.startsWith("uv_")) continue;
    out.push(f);
  }
  return out;
}
function closestIndex(times, targetMs) {
  if (!times.length || targetMs === null) return 0;
  let best = 0;
  let bestDist = Infinity;
  for (let i = 0; i < times.length; i++) {
    const t = times[i];
    if (t === null) continue;
    const d = Math.abs(t - targetMs);
    if (d < bestDist) { bestDist = d; best = i; }
  }
  return best;
}

/* ========================= VIEW SYNC ========================= */
function attachRelayoutListenerOnce() {
  if (attachRelayoutListenerOnce._done) return;
  attachRelayoutListenerOnce._done = true;

  plotDiv.on("plotly_relayout", (ev) => {
    if (!ev) return;
    const xr0 = ev["xaxis.range[0]"], xr1 = ev["xaxis.range[1]"];
    const yr0 = ev["yaxis.range[0]"], yr1 = ev["yaxis.range[1]"];
    if (xr0 !== undefined && xr1 !== undefined && yr0 !== undefined && yr1 !== undefined) {
      viewState.hasRange = true;
      viewState.autorange = false;
      viewState.xRange = [xr0, xr1];
      viewState.yRange = [yr0, yr1];
      return;
    }
    if (ev["xaxis.autorange"] === true || ev["yaxis.autorange"] === true) {
      viewState.hasRange = false;
      viewState.autorange = true;
      viewState.xRange = null;
      viewState.yRange = null;
    }
  });
}

/* ========================= LOADING ========================= */
async function loadIndex() {
  let idx = null;
  for (const url of INDEX_CANDIDATES) {
    try {
      const res = await fetch(url);
      if (res.ok) { idx = await res.json(); break; }
    } catch (_) {}
  }
  if (!idx) throw new Error("Failed to load index.json");

  const fbv = idx.frames || idx.framesByVar || idx.frames_by_var || framesByVar;
  framesByVar = {
    chl: filterFramesForVar("chl", fbv.chl || []),
    sst: filterFramesForVar("sst", fbv.sst || []),
    uv:  filterFramesForVar("uv",  fbv.uv  || [])
  ,
    bath: [{ path: BATHY_NC_URL, filename: "bathymetry.nc" }]
  };

  for (const v of Object.keys(framesByVar)) {
    framesByVar[v].sort((a, b) => {
      const ta = epochMsForFrame(v, a) ?? 0;
      const tb = epochMsForFrame(v, b) ?? 0;
      return ta - tb;
    });
    frameTimesByVar[v] = framesByVar[v].map(f => epochMsForFrame(v, f));
  }

  await setCurrentVar(currentVar, /*keepTime*/ false);
}

async function loadGridForVar(v) {
  if (gridCache[v]) return gridCache[v];

  // Special case: bathymetry is stored as NetCDF, not a grid JSON
  if (v === "bath") {
    const info = await loadBathymetryNcOnce(BATHY_NC_URL);
    gridCache[v] = info;
    return info;
  }

  const gridName = VAR_TO_GRID[v];
  const url = `data/${REGION_ID}/grids/${gridName}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Could not load grid for ${v}: ${url}`);
  const grid = await res.json();

  const lon = grid.lon, lat = grid.lat;
  if (!Array.isArray(lon) || !Array.isArray(lat) || !Array.isArray(lon[0]) || !Array.isArray(lat[0])) {
    throw new Error("Grid JSON must contain 2-D lon/lat arrays");
  }

  const ny = lon.length;
  const nx = lon[0].length;
  const xAxis = lon[0].slice();
  const yAxis = lat.map(r => r[0]);

  const info = { xAxis, yAxis, nx, ny };
  gridCache[v] = info;
  return info;
}


async function fetchFrameData(varKey, frameMeta) {
  if (varKey === "bath") return null;

  let path = frameMeta.json_path || frameMeta.path || frameMeta.file || frameMeta.url || frameMeta.json;
  if (!path) throw new Error("Frame path missing");
  if (!String(path).startsWith("data/")) path = `data/${REGION_ID}/${varKey}/${path}`;
  const res = await fetch(path);
  if (!res.ok) throw new Error(`Frame load failed: ${path}`);
  return await res.json();
}

/* ========================= STABLE LAYOUT ========================= */
function stableLayout() {
  const layout = {
    uirevision: "sync_fov_v3",
    margin: { l: 52, r: 92, t: 10, b: 40 },
    paper_bgcolor: "#050b10",
    plot_bgcolor: "#050b10",
    font: { color: "#e0e6ee" },
    xaxis: { title: "Longitude", automargin: true },
    yaxis: { title: "Latitude", automargin: true, scaleanchor: "x", scaleratio: 1 },
    hovermode: "closest",
  };

  if (viewState.hasRange && viewState.xRange && viewState.yRange) {
    layout.xaxis.range = viewState.xRange;
    layout.yaxis.range = viewState.yRange;
    layout.xaxis.autorange = false;
    layout.yaxis.autorange = false;
  } else {
    layout.xaxis.autorange = true;
    layout.yaxis.autorange = true;
  }
  return layout;
}

/* ========================= FIGURES ========================= */

/* ========================= BATHYMETRY (NetCDF) ========================= */
let bathyCache = null;

async function loadBathymetryNcOnce(url) {
  if (bathyCache) return bathyCache;

  const Reader = window.NetCDFReader || (window.netcdfjs && window.netcdfjs.NetCDFReader) || null;
  if (!Reader) {
    throw new Error("NetCDFReader not loaded. Ensure netcdfjs UMD script is included in <head>.");
  }

  const res = await fetch(url);
  if (!res.ok) throw new Error(`Failed to fetch bathymetry nc: ${url}`);
  const buf = await res.arrayBuffer();

  let reader = null;
  try {
    reader = new Reader(buf);
  } catch (e) {
    // Some UMD builds export {NetCDFReader: ...}
    const Alt = (Reader && Reader.NetCDFReader) ? Reader.NetCDFReader : null;
    if (!Alt) throw e;
    reader = new Alt(buf);
  }

  const vars = reader.variables || [];
  const vnames = new Set(vars.map(v => v.name));

  const lonName = vnames.has("lon") ? "lon" : (vnames.has("longitude") ? "longitude" : null);
  const latName = vnames.has("lat") ? "lat" : (vnames.has("latitude") ? "latitude" : null);
  if (!lonName || !latName) throw new Error("Bathymetry nc missing lon/lat variables.");

  const zName =
    vnames.has("elevation") ? "elevation" :
    (vnames.has("z") ? "z" :
     (vnames.has("depth") ? "depth" : null));

  if (!zName) {
    // fallback: first 2-D variable
    const cand = vars.find(v => (v.dimensions || []).length >= 2);
    if (!cand) throw new Error("Bathymetry nc: no 2-D variable found.");
    // eslint-disable-next-line no-unused-vars
  }

  const lon1d = reader.getDataVariable(lonName);
  const lat1d = reader.getDataVariable(latName);
  const zz = reader.getDataVariable(zName || vars.find(v => (v.dimensions || []).length >= 2).name);

  // NetCDFJS returns typed arrays. Convert to nested JS arrays for Plotly (small region only).
  const nx = lon1d.length;
  const ny = lat1d.length;

  // z is typically packed int16 -> convert to JS numbers
  const z = Array.from({ length: ny }, () => Array(nx).fill(null));
  let k = 0;
  for (let j = 0; j < ny; j++) {
    for (let i = 0; i < nx; i++) {
      const v = zz[k++];
      z[j][i] = (v === undefined || v === null) ? null : Number(v);
    }
  }

  // Use 1-D axes for Plotly heatmap
  const xAxis = Array.from(lon1d, Number);
  const yAxis = Array.from(lat1d, Number);

  bathyCache = { xAxis, yAxis, nx, ny, z };
  return bathyCache;
}

function buildBathy(gridInfo) {
  const info = bathyCache;
  if (!info) throw new Error("Bathymetry not loaded.");
  const { xAxis, yAxis, z, nx, ny } = info;

  const vmin = userRanges.bath.vmin;
  const vmax = userRanges.bath.vmax;

  return {
    data: [{
      type: "heatmap",
      x: xAxis, y: yAxis,
      z,
      customdata: z,
      hoverinfo: "none",
      zauto: false,
      zmin: vmin,
      zmax: vmax,
      colorscale: COLOR_CONFIG.bath.colorscale,
      reversescale: !!COLOR_CONFIG.bath.reversescale,
      colorbar: {
        title: { text: `Bathymetry (${DEFAULT_RANGES.bath.unit})`, side: "top", font: { size: 12 } },
        tickfont: { size: 11 },
        thickness: isPortraitMobile() ? 18 : 16,
        len: isPortraitMobile() ? 0.22 : 0.75,
        orientation: isPortraitMobile() ? "h" : "v"
      }
    }],
    layout: stableLayout()
  };
}
function buildChl(gridInfo, dataObj) {
  const { xAxis, yAxis, nx, ny } = gridInfo;
  if (!is2D(dataObj.chl)) throw new Error("CHL JSON missing 2-D key: chl");

  const vmin = userRanges.chl.vmin;
  const vmax = userRanges.chl.vmax;
  const zmin = Math.log10(vmin);
  const zmax = Math.log10(vmax);

  const z = Array.from({ length: ny }, () => Array(nx).fill(null));
  const cd = Array.from({ length: ny }, () => Array(nx).fill(null));

  for (let j = 0; j < ny; j++) {
    for (let i = 0; i < nx; i++) {
      const vv = dataObj.chl[j][i];
      const num = (vv === null || vv === undefined || !isFinite(vv)) ? null : Number(vv);
      cd[j][i] = num;
      z[j][i] = (num !== null && num > 0) ? Math.log10(num) : null;
    }
  }

  return {
    data: [{
      type: "heatmap",
      x: xAxis, y: yAxis,
      z,
      customdata: cd,
      hoverinfo: "none",
      zauto: false,
      zmin, zmax,
      colorscale: CHL_ALGAE,
      colorbar: {
        title: { text: DEFAULT_RANGES.chl.unit, side: "top" },
        x: 1.02, xanchor: "left", len: 0.92,
        tickmode: "array",
        tickvals: CHL_TICKVALS,
        ticktext: CHL_TICKTEXT,
        ticks: "outside"
      },
      zsmooth: false
    }],
    layout: stableLayout()
  };
}

function buildSst(gridInfo, dataObj) {
  const { xAxis, yAxis } = gridInfo;
  if (!is2D(dataObj.sst)) throw new Error("SST JSON missing 2-D key: sst");

  const vmin = userRanges.sst.vmin;
  const vmax = userRanges.sst.vmax;

  return {
    data: [{
      type: "heatmap",
      x: xAxis, y: yAxis,
      z: dataObj.sst,
      customdata: dataObj.sst,
      hoverinfo: "none",
      zauto: false,
      zmin: vmin,
      zmax: vmax,
      colorscale: "RdBu_r",
      reversescale: false,  // FIX: blue=cold, red=warm (RdBu default is red->blue)
      colorbar: {
        title: { text: DEFAULT_RANGES.sst.unit, side: "top" },
        x: 1.02, xanchor: "left", len: 0.92
      },
      zsmooth: false
    }],
    layout: stableLayout()
  };
}

function buildUv(gridInfo, dataObj) {
  const { xAxis, yAxis, nx, ny } = gridInfo;

  // Accept both shapes:
  //   { data: { u, v, adt|speed } }  OR  { u, v, adt|speed }
  // Some producers may write u/v at top-level while other fields are under data.
  const root = (dataObj && typeof dataObj === "object") ? dataObj : {};
  const d = (root.data && typeof root.data === "object") ? root.data : root;

  const u2d = is2D(d.u) ? d.u : (is2D(root.u) ? root.u : null);
  const v2d = is2D(d.v) ? d.v : (is2D(root.v) ? root.v : null);

  const adt2d = is2D(d.adt) ? d.adt : (is2D(root.adt) ? root.adt : null);
  let speed2d = is2D(d.speed) ? d.speed : (is2D(root.speed) ? root.speed : null);

  if (!u2d || !v2d) {
    throw new Error("UV JSON missing 2-D keys: (data.u or u) and (data.v or v)");
  }

  // Prefer ADT for background; fallback to speed; else compute speed from u/v
  if (!adt2d && !speed2d) {
    speed2d = Array.from({ length: ny }, (_, j) => {
      const row = new Array(nx);
      for (let i = 0; i < nx; i++) {
        const uu = u2d[j]?.[i];
        const vv = v2d[j]?.[i];
        if (uu == null || vv == null || Number.isNaN(uu) || Number.isNaN(vv)) row[i] = null;
        else row[i] = Math.sqrt(uu * uu + vv * vv);
      }
      return row;
    });
  }

  const bgZ = adt2d ? adt2d : speed2d;
  const bgTitle = adt2d ? "Sea Surface Height" : "Speed";

  const vmin = userRanges.uv.vmin;
  const vmax = userRanges.uv.vmax;

  const bg = {
    type:"heatmap",
    z: bgZ,
    x: xAxis,
    y: yAxis,
    zmin: (vmin != null ? vmin : undefined),
    zmax: (vmax != null ? vmax : undefined),
    colorscale: COLOR_CONFIG.uv.colorscale,
    reversescale: !!COLOR_CONFIG.uv.reversescale,
    colorbar: {
      title: { text: bgTitle, side: "top", font: { size: 12 } },
      tickfont: { size: 11 },
      thickness: isPortraitMobile() ? 18 : 16,
      len: isPortraitMobile() ? 0.22 : 0.75,
      orientation: isPortraitMobile() ? "h" : "v"
    },
    hoverinfo:"skip",
    showscale:true
  };

  // Build open arrow heads as line segments in data coordinates (so they scale with zoom)
  const stride = Math.max(1, Math.round(Math.max(nx, ny) / 40)); // ~40 arrows across
  const headAngle = 28 * Math.PI / 180;
  const headFrac = 0.45;

  const lineX = [];
  const lineY = [];

  const dx = (xAxis.length > 1) ? Math.abs(xAxis[1] - xAxis[0]) : 0.01;
  const dy = (yAxis.length > 1) ? Math.abs(yAxis[1] - yAxis[0]) : 0.01;
  const baseStep = Math.max(dx, dy);

  for (let j=0; j<ny; j+=stride){
    for (let i=0; i<nx; i+=stride){
      const uu = u2d[j]?.[i];
      const vv = v2d[j]?.[i];
      if (uu == null || vv == null || Number.isNaN(uu) || Number.isNaN(vv)) continue;

      const sp = Math.sqrt(uu*uu + vv*vv);
      if (!isFinite(sp) || sp <= 0) continue;

      const ux = uu / sp;
      const vy = vv / sp;

      const L = clamp(sp * baseStep * 2.4, baseStep * 0.25, baseStep * 2.4);

      const x0 = xAxis[i], y0 = yAxis[j];
      const x1 = x0 + ux * L;
      const y1 = y0 + vy * L;

      // shaft
      lineX.push(x0, x1, null);
      lineY.push(y0, y1, null);

      // head legs (open)
      const hx = ux * L * headFrac;
      const hy = vy * L * headFrac;

      const cosA = Math.cos(headAngle), sinA = Math.sin(headAngle);

      const lx = (hx * cosA - hy * sinA);
      const ly = (hx * sinA + hy * cosA);

      const rx = (hx * cosA + hy * sinA);
      const ry = (-hx * sinA + hy * cosA);

      lineX.push(x1, x1 - lx, null);
      lineY.push(y1, y1 - ly, null);

      lineX.push(x1, x1 - rx, null);
      lineY.push(y1, y1 - ry, null);
    }
  }

  const arrows = {
    type:"scatter",
    mode:"lines",
    x: lineX,
    y: lineY,
    hoverinfo:"none",
    line:{ color:"#000000", width: isPortraitMobile() ? 1.2 : 1.6 },
    showlegend:false
  };

  return { data:[bg, arrows], layout: stableLayout() };
}



function buildForVar(varKey, gridInfo, dataObj) {
  if (varKey === "chl")  return buildChl(gridInfo, dataObj);
  if (varKey === "sst")  return buildSst(gridInfo, dataObj);
  if (varKey === "uv")   return buildUv(gridInfo, dataObj);
  if (varKey === "bath") return buildBathy(gridInfo);
  throw new Error(`Unsupported varKey=${varKey}`);
}


/* ========================= READOUT ========================= */
function setupReadoutHandlersOnce() {
  if (_readoutHooked) return;
  _readoutHooked = true;

  plotDiv.on("plotly_unhover", () => setReadout(""));

  plotDiv.on("plotly_hover", (ev) => {
    const p = ev.points && ev.points[0];
    if (!p) return;
    const lon = Number(p.x);
    const lat = Number(p.y);
    if (!isFinite(lon) || !isFinite(lat)) return;

    const base = `${lon.toFixed(3)} ${lat.toFixed(3)}`;
    const cd = p.customdata;

    if (cd === null || cd === undefined || !isFinite(cd)) { setReadout(base); return; }

    const val = Number(cd);
    if (currentVar === "sst") setReadout(`${base} ${val.toFixed(2)}`);
    else setReadout(`${base} ${val.toFixed(3)}`);
  });
}

/* ========================= UI ========================= */
function syncRangeInputsToVar() {
  if (!userRanges[currentVar]) return;
  const r = userRanges[currentVar];
  rangeTitle.textContent = `${VAR_LABELS[currentVar]} range`;
  vminInput.value = r.vmin;
  vmaxInput.value = r.vmax;
}

function updateSliderUI() {
  const frames = framesByVar[currentVar] || [];
  const n = frames.length;

  slider.min = 0;
  slider.max = Math.max(0, n - 1);
  slider.value = Math.min(currentFrameIdx, Math.max(0, n - 1));

  prevBtn.disabled = n <= 1;
  nextBtn.disabled = n <= 1;
  playBtn.disabled = n <= 1;

  frameLbl.textContent = n ? timeOnlyLabel(currentVar, frames[currentFrameIdx]) : "";
}

/* Fix #1: when switching vars, jump to closest time */
async function setCurrentVar(v, keepTime = true) {
  const prevVar = currentVar;
  const prevFrames = framesByVar[prevVar] || [];
  const prevFrame = prevFrames[currentFrameIdx] || null;
  const prevT = (keepTime && prevFrame) ? epochMsForFrame(prevVar, prevFrame) : null;

  currentVar = v;
  varSelect.value = v;

  const frames = framesByVar[currentVar] || [];
  const times = frameTimesByVar[currentVar] || [];

  if (frames.length) {
    currentFrameIdx = (keepTime && prevT !== null) ? closestIndex(times, prevT) : 0;
  } else {
    currentFrameIdx = 0;
  }

  syncRangeInputsToVar();
  updateSliderUI();

  if (frames.length) await showFrame();
  else Plotly.purge(plotDiv);
}

function stepFrame(delta) {
  const frames = framesByVar[currentVar] || [];
  const n = frames.length;
  if (!n) return;
  currentFrameIdx = (currentFrameIdx + delta + n) % n;
  slider.value = currentFrameIdx;
  showFrame();
}

function setPlaying(on) {
  if (on === playing) return;
  playing = on;
  playBtn.textContent = playing ? "Pause" : "Play";
  if (playing) {
    if (playTimer) clearInterval(playTimer);
    playTimer = setInterval(() => stepFrame(+1), 800);
  } else {
    if (playTimer) clearInterval(playTimer);
    playTimer = null;
  }
}

/* ========================= RENDER ========================= */
async function showFrame() {
  const frames = framesByVar[currentVar] || [];
  if (!frames.length) return;

  const frameMeta = frames[currentFrameIdx];

  try {
    const [gridInfo, dataObj] = await Promise.all([
      loadGridForVar(currentVar),
      fetchFrameData(currentVar, frameMeta)
    ]);

    const fig = buildForVar(currentVar, gridInfo, dataObj);

    await Plotly.react(plotDiv, fig.data, fig.layout, {
      responsive: true,
      displayModeBar: true,
      scrollZoom: true
    });

    setupReadoutHandlersOnce();
    attachRelayoutListenerOnce();
    updateSliderUI();
  } catch (err) {
    console.error("Error showing frame:", err);
  }
}

/* ========================= EVENTS ========================= */
varSelect.addEventListener("change", () => {
  setPlaying(false);
  setCurrentVar(varSelect.value, true);
});

slider.addEventListener("input", () => {
  currentFrameIdx = Number(slider.value) || 0;
  showFrame();
});

playBtn.addEventListener("click", () => setPlaying(!playing));
prevBtn.addEventListener("click", () => { setPlaying(false); stepFrame(-1); });
nextBtn.addEventListener("click", () => { setPlaying(false); stepFrame(+1); });

applyBtn.addEventListener("click", () => {
  const vmin = Number(vminInput.value);
  const vmax = Number(vmaxInput.value);
  if (!isFinite(vmin) || !isFinite(vmax) || vmax <= vmin) return;
  userRanges[currentVar].vmin = vmin;
  userRanges[currentVar].vmax = vmax;
  showFrame();
});

resetBtn.addEventListener("click", () => {
  userRanges[currentVar] = { ...DEFAULT_RANGES[currentVar] };
  syncRangeInputsToVar();
  showFrame();
});

/* ========================= INIT ========================= */
(async function init() {
  try {
    await loadIndex();
    syncRangeInputsToVar();
  } catch (e) {
    console.error("Init failed:", e);
  }
})();
</script>

</body>
</html>

