<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LiveFish Edge</title>
  <link rel="icon" href="data:,">
  <script src="https://cdn.plot.ly/plotly-2.34.0.min.js"></script>
  <!-- NetCDF v3 reader for in-browser GEBCO bathymetry -->
  <script src="https://cdn.jsdelivr.net/npm/netcdfjs@0.7.0/dist/netcdfjs.min.js"></script>

  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #050b10;
      color: #e0e6ee;
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      overflow: auto;
    }

    #controls {
      position: sticky;
      top: 0;
      z-index: 20;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      padding: 8px 10px;
      background: rgba(5, 11, 16, 0.92);
      border-bottom: 1px solid #1b2836;
      backdrop-filter: blur(6px);
    }

    #controls .row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      width: 100%;
    }

    .lbl { opacity: 0.9; font-size: 14px; }
    select, button, input {
      background: #0c141d;
      color: #e0e6ee;
      border: 1px solid #263649;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 14px;
    }
    button { cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: default; }

    #slider { width: min(640px, 100%); }
    #timeLabel { font-size: 18px; font-weight: 650; letter-spacing: 0.2px; }

    #plotWrap {
      position: relative;
      width: 100%;
      max-width: 100vw;
      height: calc(100vh - 60px);
      min-height: 520px;
    }

    #plot {
      width: 100%;
      height: 100%;
    }

    /* Floating cursor/tap readout */
    #readout {
      position: fixed;
      right: 10px;
      top: calc(var(--controlsH, 60px) + 10px);
      z-index: 50;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.18);
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 12px;
      pointer-events: none;
      max-width: 45vw;
      text-align: right;
    }

    /* Float Plotly modebar too */
    #plot .modebar {
      position: fixed !important;
      left: 10px !important;
      right: auto !important;
      top: calc(var(--controlsH, 60px) + 10px) !important;
      z-index: 60 !important;
    }

    /* Bottom range controls */
    #ranges {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      padding: 10px;
      border-top: 1px solid #1b2836;
      background: rgba(5, 11, 16, 0.92);
    }

    #ranges .mini {
      font-size: 12px;
      opacity: 0.95;
    }

    #ranges input[type="number"] {
      width: 90px;
      padding: 5px 8px;
      font-size: 12px;
    }

    /* Mobile portrait: stack controls, colorbar handled in JS */
    @media (max-width: 640px) {
      #timeLabel { font-size: 16px; }
      select, button, input { font-size: 13px; padding: 6px 8px; }
      #readout { font-size: 11px; max-width: 60vw; }
      #plotWrap { height: calc(100vh - 120px); min-height: 460px; }
      #ranges input[type="number"] { width: 78px; }
    }
  </style>
</head>

<body>
  <div id="controls">
    <div class="row">
      <select id="varSel">
        <option value="chl">Chlorophyll</option>
        <option value="sst">Temperature</option>
        <option value="uv">Currents</option>
        <option value="bathy">Bathymetry</option>
      </select>

      <button id="prevBtn">⟨</button>
      <button id="playBtn">▶</button>
      <button id="nextBtn">⟩</button>

      <input id="slider" type="range" min="0" max="0" step="1" value="0" />
      <div id="timeLabel"></div>
    </div>
  </div>

  <div id="plotWrap">
    <div id="plot"></div>
  </div>

  <div id="readout"></div>

  <div id="ranges">
    <span class="mini" id="rangeLabel">Range</span>
    <span class="mini" id="vminLabel">vmin</span>
    <input id="vminInput" type="number" step="0.01" />
    <span class="mini" id="vmaxLabel">vmax</span>
    <input id="vmaxInput" type="number" step="0.01" />
    <button id="applyRangeBtn">Apply</button>
    <button id="resetRangeBtn">Reset</button>
  </div>

<script>
/* ========================= CONFIG ========================= */
const REGION_ID = "mbh";

const GRID_FILES = {
  chl: "viirs_chl_750_grid.json",
  sst: "goes_sst_1000_grid.json",
  uv:  "uv_12500_grid.json"
};

const VAR_LABELS = {
  chl: "Chlorophyll",
  sst: "Temperature",
  uv:  "Currents",
  bathy: "Bathymetry"
};

const DEFAULT_RANGES = {
  chl: { vmin: 0.01, vmax: 10.0, unit: "mg/m³" },
  sst: { vmin: 23.0, vmax: 28.0, unit: "°C" },
  uv:  { vmin: -0.5, vmax: 0.5, unit: "m" },   // SSH placeholder range
  bathy: { vmin: 0, vmax: 5000, unit: "m" }
};

// CHL uses log10 coloring but we label ticks in linear units
const CHL_TICKS_LINEAR = [0.01,0.02,0.03,0.05,0.07,0.1,0.2,0.3,0.5,0.7,1,2,3,5,7,10];
const CHL_TICKVALS = CHL_TICKS_LINEAR.map(v => Math.log10(v));
const CHL_TICKTEXT = CHL_TICKS_LINEAR.map(v => (v===0.01||v===0.1||v===1||v===10) ? String(v) : "");

/* Currents arrow styling (VISIBLE heads) */
const CURRENT_ARROW_STEP_MAXPTS = 50 * 50;
const CURRENT_ARROW_SCALE = 0.08;
const CURRENT_HEAD_SIZE = 0.2;
const CURRENT_LINE_W = 1;

/* ========================= STATE ========================= */
let framesByVar = { chl: [], sst: [], uv: [], bathy: [{ id: "bathy" }] };
let frameTimesByVar = { chl: [], sst: [], uv: [], bathy: [0] }; // epoch ms for closest-timestep mapping
let currentVar = "chl";
let currentFrameIdx = 0;
let playing = false;
let playTimer = null;
let savedView = null;

let gridCache = {};
let _readoutHooked = false;

/* ========================= DOM ========================= */
const plotDiv = document.getElementById("plot");
const varSel = document.getElementById("varSel");
const prevBtn = document.getElementById("prevBtn");
const playBtn = document.getElementById("playBtn");
const nextBtn = document.getElementById("nextBtn");
const slider = document.getElementById("slider");
const timeLabel = document.getElementById("timeLabel");
const readout = document.getElementById("readout");

const rangeLabel = document.getElementById("rangeLabel");
const vminInput = document.getElementById("vminInput");
const vmaxInput = document.getElementById("vmaxInput");
const applyRangeBtn = document.getElementById("applyRangeBtn");
const resetRangeBtn = document.getElementById("resetRangeBtn");

/* ========================= HELPERS ========================= */
function isPortrait() {
  return window.innerWidth <= 640 || (window.innerWidth < window.innerHeight);
}

function setControlsHeightCSSVar() {
  const h = document.getElementById("controls").offsetHeight;
  document.documentElement.style.setProperty("--controlsH", `${h}px`);
}

function is2D(x) {
  return Array.isArray(x) && Array.isArray(x[0]);
}

function clamp(x, a, b) {
  return Math.max(a, Math.min(b, x));
}

function fmt2(x) {
  if (x === null || x === undefined || !isFinite(x)) return "";
  return Number(x).toFixed(2);
}

function fmt3(x) {
  if (x === null || x === undefined || !isFinite(x)) return "";
  return Number(x).toFixed(3);
}

/* ========================= TIME PARSERS ========================= */
function parseChlUtcFromName(filename) {
  // mbh_2025336.1742_20251202_chl_VJ2.json (HHMM after dot)
  const m = filename.match(/_(\d{4})(\d{3})\.(\d{4})_/);
  if (!m) return null;
  const year = Number(m[1]);
  const doy = Number(m[2]);
  const hhmm = m[3];
  const hh = Number(hhmm.slice(0,2));
  const mm = Number(hhmm.slice(2,4));

  const d0 = new Date(Date.UTC(year,0,1,0,0,0));
  const dt = new Date(d0.getTime() + (doy-1)*86400*1000);
  dt.setUTCHours(hh, mm, 0, 0);
  return dt;
}

function parseSstUtcFromName(filename) {
  // sst_mbh_2025338_20251204_03_g19.json (HH)
  const m = filename.match(/^sst_.*?_(\d{4})(\d{3})_(\d{4})_(\d{2})_/);
  if (!m) return null;
  const year = Number(m[1]);
  const doy = Number(m[2]);
  const hh = Number(m[4]);

  const d0 = new Date(Date.UTC(year,0,1,0,0,0));
  const dt = new Date(d0.getTime() + (doy-1)*86400*1000);
  dt.setUTCHours(hh, 0, 0, 0);
  return dt;
}

function parseUvDateFromName(filename) {
  // uv_mbh_2025345_20251211_cmems-duacs-v202506.json (date-only)
  const m = filename.match(/_(\d{8})_/);
  if (!m) return null;
  const y = Number(m[1].slice(0,4));
  const mo = Number(m[1].slice(4,6));
  const da = Number(m[1].slice(6,8));
  return new Date(Date.UTC(y, mo-1, da, 0,0,0));
}

function epochMsForFrame(varKey, frameMeta) {
  if (varKey === "bathy") return 0;
  const path = frameMeta.json_path || frameMeta.path || frameMeta.file || "";
  const filename = String(path).split("/").pop() || "";
  let dt = null;
  if (varKey === "chl") dt = parseChlUtcFromName(filename);
  if (varKey === "sst") dt = parseSstUtcFromName(filename);
  if (varKey === "uv")  dt = parseUvDateFromName(filename); // date-only
  return dt ? dt.getTime() : null;
}

function formatTimeLabel(varKey, dtMs) {
  if (varKey === "uv") {
    // date-only (daily mean)
    const dt = new Date(dtMs);
    const mm = String(dt.getUTCMonth()+1).padStart(2,"0");
    const dd = String(dt.getUTCDate()).padStart(2,"0");
    const yy = dt.getUTCFullYear();
    return `${mm}/${dd}/${yy}`;
  }
  // show local time
  const dt = new Date(dtMs);
  const mm = String(dt.getMonth()+1).padStart(2,"0");
  const dd = String(dt.getDate()).padStart(2,"0");
  const yy = dt.getFullYear();
  const hh = String(dt.getHours()).padStart(2,"0");
  const mi = String(dt.getMinutes()).padStart(2,"0");
  return `${mm}/${dd}/${yy}, ${hh}:${mi}`;
}

/* ========================= IO ========================= */
async function fetchJson(url) {
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
  return await r.json();
}

async function loadIndex() {
  const idx = await fetchJson("index.json");
  const fbv = idx.frames || idx.framesByVar || idx.frames_by_var || framesByVar;

  framesByVar = {
    chl: filterFramesForVar("chl", fbv.chl || []),
    sst: filterFramesForVar("sst", fbv.sst || []),
    uv:  filterFramesForVar("uv",  fbv.uv  || []),
    bathy: [{ id: "bathy" }]
  };

  for (const v of Object.keys(framesByVar)) {
    framesByVar[v].sort((a, b) => {
      const ta = epochMsForFrame(v, a) ?? 0;
      const tb = epochMsForFrame(v, b) ?? 0;
      return ta - tb;
    });
    frameTimesByVar[v] = framesByVar[v].map(f => epochMsForFrame(v, f) ?? 0);
  }

  console.log("Loaded index.json from index.json");
}

function filterFramesForVar(v, frames) {
  return frames.map(f => ({
    ...f,
    // normalize path field
    _path: f.json_path || f.path || f.file || f.filename || f.name || ""
  }));
}

async function loadGridForVar(v) {
  if (v === "bathy") return null;
  if (gridCache[v]) return gridCache[v];

  const url = `data/${REGION_ID}/grids/${GRID_FILES[v]}`;
  const g = await fetchJson(url);

  // Expect 2-D lon/lat
  const lon2d = g.lon2d || g.lon || g.longitude || g.LON || g.nav_lon || g.x2d;
  const lat2d = g.lat2d || g.lat || g.latitude || g.LAT || g.nav_lat || g.y2d;
  if (!is2D(lon2d) || !is2D(lat2d)) throw new Error(`Grid missing 2-D lon/lat in ${url}`);

  const ny = lat2d.length;
  const nx = lat2d[0].length;

  // Plotly heatmap wants 1D x/y or 2D x/y. We'll use 1D axes from first row/col.
  const xAxis = lon2d[0].slice();
  const yAxis = lat2d.map(r => r[0]);

  gridCache[v] = { lon2d, lat2d, xAxis, yAxis, nx, ny };
  console.log(`Loaded grid for ${v} from ${url}`);
  return gridCache[v];
}

async function fetchFrameData(v, frameMeta) {
  const path = frameMeta._path || "";
  const url = path.startsWith("data/") ? path : `data/${REGION_ID}/${v}/${path}`;
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error(`Frame load failed: ${url}`);
  return await r.json();
}

/* ========================= LAYOUT ========================= */
function stableLayout() {
  const portrait = isPortrait();
  const marginRight = portrait ? 10 : 90;
  const marginBottom = portrait ? 80 : 40;

  return {
    paper_bgcolor: "#050b10",
    plot_bgcolor: "#050b10",
    margin: { l: 60, r: marginRight, t: 10, b: marginBottom },
    xaxis: {
      title: "",
      showgrid: false,
      zeroline: false,
      tickcolor: "#9fb4cc",
      tickfont: { size: 12, color: "#cfe0f0" },
      fixedrange: false
    },
    yaxis: {
      title: "",
      showgrid: false,
      zeroline: false,
      tickcolor: "#9fb4cc",
      tickfont: { size: 12, color: "#cfe0f0" },
      scaleanchor: "x",
      scaleratio: 1,
      fixedrange: false
    },
    showlegend: false
  };
}

/* ========================= FIG BUILDERS ========================= */
let rangesByVar = JSON.parse(JSON.stringify(DEFAULT_RANGES));

function buildChl(gridInfo, dataObj) {
  const { xAxis, yAxis, nx, ny } = gridInfo;
  const vmin = rangesByVar.chl.vmin;
  const vmax = rangesByVar.chl.vmax;

  const z = dataObj.chl || (dataObj.data && dataObj.data.chl);
  if (!is2D(z)) return { data: [], layout: stableLayout() };

  const zlog = Array.from({ length: ny }, () => new Array(nx));
  const cd = Array.from({ length: ny }, () => new Array(nx));
  for (let j = 0; j < ny; j++) {
    for (let i = 0; i < nx; i++) {
      const v = z[j][i];
      if (v === null || v === undefined || !isFinite(v) || v <= 0) {
        zlog[j][i] = null;
        cd[j][i] = null;
      } else {
        zlog[j][i] = Math.log10(v);
        cd[j][i] = Number(v);
      }
    }
  }

  const portrait = isPortrait();
  const cb = portrait
    ? { title: { text: DEFAULT_RANGES.chl.unit, side: "top" }, orientation: "h", x: 0.5, xanchor: "center", y: -0.12, len: 0.92 }
    : { title: { text: DEFAULT_RANGES.chl.unit, side: "top" }, x: 1.02, xanchor: "left", len: 0.92 };

  return {
    data: [{
      type: "heatmap",
      x: xAxis, y: yAxis,
      z: zlog,
      customdata: cd,
      hoverinfo: "none",
      zauto: false,
      zmin: Math.log10(vmin),
      zmax: Math.log10(vmax),
      colorscale: "Turbo",
      reversescale: false,
      colorbar: { ...cb, tickmode: "array", tickvals: CHL_TICKVALS, ticktext: CHL_TICKTEXT },
      zsmooth: false
    }],
    layout: stableLayout()
  };
}

function buildSst(gridInfo, dataObj) {
  const { xAxis, yAxis } = gridInfo;
  const vmin = rangesByVar.sst.vmin;
  const vmax = rangesByVar.sst.vmax;

  const z = dataObj.sst || (dataObj.data && dataObj.data.sst);
  if (!is2D(z)) return { data: [], layout: stableLayout() };

  const cd = z.map(row => row.map(v => (v === null || v === undefined || !isFinite(v)) ? null : Number(v)));

  const portrait = isPortrait();
  const cb = portrait
    ? { title: { text: DEFAULT_RANGES.sst.unit, side: "top" }, orientation: "h", x: 0.5, xanchor: "center", y: -0.12, len: 0.92 }
    : { title: { text: DEFAULT_RANGES.sst.unit, side: "top" }, x: 1.02, xanchor: "left", len: 0.92 };

  return {
    data: [{
      type: "heatmap",
      x: xAxis, y: yAxis,
      z: z,
      customdata: cd,
      hoverinfo: "none",
      zauto: false,
      zmin: vmin,
      zmax: vmax,
      colorscale: [[0.0,"#08306b"],[0.5,"#f7f7f7"],[1.0,"#b2182b"]],
      reversescale: false,
      colorbar: cb,
      zsmooth: false
    }],
    layout: stableLayout()
  };
}

// -------------------- Bathymetry (GEBCO NetCDF) --------------------
const BATHY_CFG = {
  // repo-relative path; keep under data/<region>/...
  // e.g. data/mbh/gebco_bath_20251208/gebco_2025_n28.5_s24.5_w-79.0_e-75.0.nc
  subdir: "gebco_bath_20251208",
  filename: "gebco_2025_n28.5_s24.5_w-79.0_e-75.0.nc",
  varName: "elevation", // meters, positive up
};

let bathyCache = null;

function getBathyPath() {
  return `data/${REGION_ID}/${BATHY_CFG.subdir}/${BATHY_CFG.filename}`;
}

async function loadBathymetryNcOnce() {
  if (bathyCache) return bathyCache;

  // netcdfjs@0.7.0 UMD exposes window.netcdfjs.NetCDFReader (and sometimes window.NetCDFReader)
  const Reader = window.NetCDFReader || (window.netcdfjs && window.netcdfjs.NetCDFReader);
  if (!Reader) {
    throw new Error("NetCDFReader not loaded. Ensure netcdfjs UMD script is included in <head>.");
  }

  const resp = await fetch(getBathyPath(), { cache: "no-store" });
  if (!resp.ok) throw new Error(`Failed to fetch bathymetry NC: ${getBathyPath()} (${resp.status})`);
  const ab = await resp.arrayBuffer();

  const reader = new Reader(ab);

  // 1D lon/lat
  const lon = reader.getDataVariable("lon") || reader.getDataVariable("x") || reader.getDataVariable("longitude");
  const lat = reader.getDataVariable("lat") || reader.getDataVariable("y") || reader.getDataVariable("latitude");
  const elev = reader.getDataVariable(BATHY_CFG.varName) || reader.getDataVariable("z") || reader.getDataVariable("elevation");

  if (!lon || !lat || !elev) {
    const vars = (reader.variables || []).map(v => v.name).join(", ");
    throw new Error(`Bathymetry NC missing lon/lat/elevation. Vars: ${vars}`);
  }

  const nx = lon.length;
  const ny = lat.length;

  // Convert elevation (positive up) -> depth (positive down), mask land (elev >= 0) as null
  const depth = Array.from({ length: ny }, () => new Array(nx));
  for (let j = 0; j < ny; j++) {
    for (let i = 0; i < nx; i++) {
      const idx = j * nx + i;
      const z = elev[idx];
      if (z === null || z === undefined || !isFinite(z)) { depth[j][i] = null; continue; }
      const zz = Number(z);
      depth[j][i] = (zz >= 0) ? null : -zz;
    }
  }

  bathyCache = { lon: Array.from(lon), lat: Array.from(lat), depth, nx, ny };
  console.log(`Loaded bathymetry NC ${nx}x${ny} from ${getBathyPath()}`);
  return bathyCache;
}

function buildBathy(bathy) {
  const vmin = rangesByVar.bathy?.vmin ?? 0;
  const vmax = rangesByVar.bathy?.vmax ?? 5000;

  // Build customdata so the hover/tap overlay can show a value when present.
  const cd = bathy.depth.map(row => row.map(v => (v === null || v === undefined || !isFinite(v)) ? null : Number(v)));

  const colorbar = isPortrait()
    ? { title: { text: "Depth<br>(m)", side: "top" }, orientation: "h", x: 0.5, xanchor: "center", y: -0.12, len: 0.92 }
    : { title: { text: "Depth<br>(m)", side: "top" }, x: 1.02, xanchor: "left", len: 0.92 };

  return {
    data: [{
      type: "heatmap",
      x: bathy.lon,
      y: bathy.lat,
      z: bathy.depth,
      customdata: cd,
      hoverinfo: "none",
      zauto: false,
      zmin: vmin,
      zmax: vmax,
      colorscale: "Earth",
      reversescale: false,
      colorbar,
      zsmooth: false
    }],
    layout: stableLayout()
  };
}

function buildUv(gridInfo, dataObj) {
  const { xAxis, yAxis, nx, ny } = gridInfo;
  const d = dataObj.data || dataObj;

  if (!d || !is2D(d.u) || !is2D(d.v) || !(is2D(d.adt) || is2D(d.speed))) {
    throw new Error("UV JSON missing 2-D keys: data.u, data.v, and (data.adt or data.speed)");
  }

  const u = d.u, v = d.v;
  const bgField = is2D(d.adt) ? d.adt : d.speed; // prefer SSH (adt); fallback to speed

  // background heatmap (Sea Surface Height; falls back to speed placeholder if adt missing)
  const cd = Array.from({ length: ny }, () => Array(nx).fill(null));
  for (let j = 0; j < ny; j++) {
    for (let i = 0; i < nx; i++) {
      const sp = bgField[j][i];
      cd[j][i] = (sp === null || sp === undefined || !isFinite(sp)) ? null : Number(sp);
    }
  }

  const vmin = rangesByVar.uv.vmin;
  const vmax = rangesByVar.uv.vmax;

  const portrait = isPortrait();
  const cb = portrait
    ? { title: { text: "Sea Surface Height<br>(m)", side: "top" }, orientation: "h", x: 0.5, xanchor: "center", y: -0.12, len: 0.92 }
    : { title: { text: "Sea Surface Height<br>(m)", side: "top" }, x: 1.02, xanchor: "left", len: 0.92 };

  const bg = {
    type: "heatmap",
    x: xAxis, y: yAxis,
    z: bgField,
    customdata: cd,
    hoverinfo: "none",
    zauto: false,
    zmin: vmin,
    zmax: vmax,
    colorscale: "Cividis",
    reversescale: false,
    colorbar: cb,
    zsmooth: false
  };

  // Build arrow segments as a single scattergl trace with NaN breaks
  const step = Math.max(1, Math.ceil(Math.sqrt((nx * ny) / CURRENT_ARROW_STEP_MAXPTS)));
  const lineX = [];
  const lineY = [];

  // Grid spacing used for minimum head length
  const dxg = (nx > 1) ? Math.abs(xAxis[1] - xAxis[0]) : 0.02;
  const dyg = (ny > 1) ? Math.abs(yAxis[1] - yAxis[0]) : 0.02;

  const minHead = 0.9 * Math.max(dxg, dyg);    // ensures heads visible
  const headFrac = 0.55;                       // head length as fraction of arrow length
  const headAngleDeg = 28;                     // "V" opening
  const headAngle = headAngleDeg * Math.PI / 180;

  for (let j = 0; j < ny; j += step) {
    const lat0 = yAxis[j];
    for (let i = 0; i < nx; i += step) {
      const lon0 = xAxis[i];
      const uu = u[j][i];
      const vv = v[j][i];
      if (!isFinite(uu) || !isFinite(vv)) continue;

      // tip in lon/lat units
      const lon1 = lon0 + uu * CURRENT_ARROW_SCALE;
      const lat1 = lat0 + vv * CURRENT_ARROW_SCALE;

      const dx = lon1 - lon0;
      const dy = lat1 - lat0;
      const L = Math.hypot(dx, dy);
      if (!(L > 0)) continue;

      // Shaft
      lineX.push(lon0, lon1, null);
      lineY.push(lat0, lat1, null);

      // Open "V" head
      const theta = Math.atan2(dy, dx);
      const hl = Math.max(minHead, headFrac * L);

      const xL = lon1 + hl * Math.cos(theta + Math.PI - headAngle);
      const yL = lat1 + hl * Math.sin(theta + Math.PI - headAngle);
      const xR = lon1 + hl * Math.cos(theta + Math.PI + headAngle);
      const yR = lat1 + hl * Math.sin(theta + Math.PI + headAngle);

      lineX.push(lon1, xL, null, lon1, xR, null);
      lineY.push(lat1, yL, null, lat1, yR, null);
    }
  }

  const arrows = {
    type: "scattergl",
    mode: "lines",
    x: lineX,
    y: lineY,
    hoverinfo: "none",
    line: { color: "#000000", width: CURRENT_LINE_W },
    showlegend: false
  };

  return { data: [bg, arrows], layout: stableLayout() };
}

function buildForVar(varKey, gridInfo, dataObj) {
  if (varKey === "chl") return buildChl(gridInfo, dataObj);
  if (varKey === "sst") return buildSst(gridInfo, dataObj);
  if (varKey === "uv")  return buildUv(gridInfo, dataObj);
  if (varKey === "bathy") return { __bathy__: true };
  throw new Error(`Unsupported varKey=${varKey}`);
}

/* ========================= READOUT ========================= */
function setupReadoutHandlersOnce() {
  if (_readoutHooked) return;
  _readoutHooked = true;

  plotDiv.on("plotly_unhover", () => setReadout(""));

  plotDiv.on("plotly_hover", (ev) => {
    const p = ev.points && ev.points[0];
    if (!p) return;

    const lon = (p.x !== undefined) ? Number(p.x) : null;
    const lat = (p.y !== undefined) ? Number(p.y) : null;

    // Find value from customdata when present
    let val = null;
    if (p.customdata !== undefined && p.customdata !== null && isFinite(p.customdata)) {
      val = Number(p.customdata);
    }

    // numbers only, no "lon=" or "lat="
    if (val === null) {
      setReadout(`${fmt3(lon)}  ${fmt3(lat)}`);
    } else {
      if (currentVar === "sst") setReadout(`${fmt3(lon)}  ${fmt3(lat)}  ${fmt2(val)}`);
      else setReadout(`${fmt3(lon)}  ${fmt3(lat)}  ${val}`);
    }
  });

  // persist view state (zoom/pan sync across vars/times)
  plotDiv.on("plotly_relayout", (ev) => {
    const hasX = ("xaxis.range[0]" in ev) || ("xaxis.range" in ev);
    const hasY = ("yaxis.range[0]" in ev) || ("yaxis.range" in ev);
    if (hasX || hasY) {
      savedView = ev;
    }
  });
}

function setReadout(s) {
  readout.textContent = s || "";
}

function applySavedViewIfAny() {
  if (!savedView) return;
  // Apply as best-effort
  Plotly.relayout(plotDiv, savedView).catch(()=>{});
}

/* ========================= UI ========================= */
function setRangeUIForVar(v) {
  const r = rangesByVar[v] || DEFAULT_RANGES[v];
  if (!r) return;

  rangeLabel.textContent = (v === "chl") ? "Chlorophyll" :
                           (v === "sst") ? "Temperature" :
                           (v === "uv")  ? "Sea Surface Height" :
                           "Bathymetry";
  vminInput.value = r.vmin;
  vmaxInput.value = r.vmax;

  // Make SST row tighter on mobile
  if (v === "sst") {
    vminInput.step = "0.1";
    vmaxInput.step = "0.1";
  } else if (v === "chl") {
    vminInput.step = "0.01";
    vmaxInput.step = "0.01";
  } else {
    vminInput.step = "0.1";
    vmaxInput.step = "0.1";
  }
}

function updateSliderUI() {
  const frames = framesByVar[currentVar] || [];
  const n = frames.length;

  slider.min = 0;
  slider.max = Math.max(0, n - 1);
  slider.value = Math.min(currentFrameIdx, Math.max(0, n - 1));

  if (currentVar === "bathy") {
    slider.min = 0; slider.max = 0; slider.value = 0;
    prevBtn.disabled = true; nextBtn.disabled = true; playBtn.disabled = true;
  } else {
    prevBtn.disabled = n <= 1;
    nextBtn.disabled = n <= 1;
    playBtn.disabled = n <= 1;
  }
}

function stopPlaying() {
  playing = false;
  playBtn.textContent = "▶";
  if (playTimer) clearInterval(playTimer);
  playTimer = null;
}

function setPlaying(on) {
  if (on) {
    if (playing) return;
    playing = true;
    playBtn.textContent = "⏸";
    playTimer = setInterval(() => stepFrame(1), 700);
  } else {
    stopPlaying();
  }
}

function stepFrame(dir) {
  const frames = framesByVar[currentVar] || [];
  if (frames.length <= 1) return;

  currentFrameIdx = (currentFrameIdx + dir + frames.length) % frames.length;
  slider.value = currentFrameIdx;
  showFrame().catch(console.error);
}

/* Closest-timestep switching across variables */
function findClosestFrameIndex(varKey, targetMs) {
  const t = frameTimesByVar[varKey] || [];
  if (!t.length) return 0;
  // binary search
  let lo = 0, hi = t.length - 1;
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (t[mid] < targetMs) lo = mid + 1;
    else hi = mid;
  }
  const i = lo;
  const i0 = clamp(i-1, 0, t.length-1);
  const i1 = clamp(i,   0, t.length-1);
  return (Math.abs(t[i0]-targetMs) <= Math.abs(t[i1]-targetMs)) ? i0 : i1;
}

/* ========================= RENDER ========================= */
async function showFrame() {
  const frames = framesByVar[currentVar] || [];
  if (!frames.length && currentVar !== "bathy") return;

  const frameMeta = frames[currentFrameIdx];

  try {
    // Bathymetry is a static NetCDF (no per-frame JSON, no per-var grid)
    if (currentVar === "bathy") {
      const bathy = await loadBathymetryNcOnce();
      const figB = buildBathy(bathy);

      await Plotly.react(plotDiv, figB.data, figB.layout, {
        responsive: true,
        displayModeBar: true,
        scrollZoom: true
      });

      setupReadoutHandlersOnce();
      applySavedViewIfAny();
      timeLabel.textContent = "";
      return;
    }

    const [gridInfo, dataObj] = await Promise.all([
      loadGridForVar(currentVar),
      fetchFrameData(currentVar, frameMeta)
    ]);

    const fig = buildForVar(currentVar, gridInfo, dataObj);

    await Plotly.react(plotDiv, fig.data, fig.layout, {
      responsive: true,
      displayModeBar: true,
      scrollZoom: true
    });

    setupReadoutHandlersOnce();
    applySavedViewIfAny();

    // Update time label from filename parse
    const ms = epochMsForFrame(currentVar, frameMeta);
    timeLabel.textContent = ms ? formatTimeLabel(currentVar, ms) : "";

  } catch (e) {
    console.error("Error showing frame:", e);
  }
}

async function setCurrentVar(v) {
  stopPlaying();

  const oldVar = currentVar;
  const oldFrames = framesByVar[oldVar] || [];
  const oldMeta = oldFrames[currentFrameIdx];
  const oldMs = (oldVar === "bathy") ? null : epochMsForFrame(oldVar, oldMeta);

  currentVar = v;

  // Keep closest timestep when switching vars
  if (oldMs !== null && v !== "bathy") {
    currentFrameIdx = findClosestFrameIndex(v, oldMs);
  } else {
    currentFrameIdx = 0;
  }

  setRangeUIForVar(v);
  updateSliderUI();
  await showFrame();
}

/* ========================= EVENTS ========================= */
varSel.addEventListener("change", async () => {
  await setCurrentVar(varSel.value);
});

prevBtn.addEventListener("click", () => stepFrame(-1));
nextBtn.addEventListener("click", () => stepFrame(1));

playBtn.addEventListener("click", () => {
  if (currentVar === "bathy") return;
  setPlaying(!playing);
});

slider.addEventListener("input", () => {
  stopPlaying();
  currentFrameIdx = Number(slider.value);
  showFrame().catch(console.error);
});

applyRangeBtn.addEventListener("click", () => {
  const v = currentVar;
  const vmin = Number(vminInput.value);
  const vmax = Number(vmaxInput.value);
  if (!isFinite(vmin) || !isFinite(vmax) || !(vmax > vmin)) return;
  rangesByVar[v] = { ...rangesByVar[v], vmin, vmax };
  showFrame().catch(console.error);
});

resetRangeBtn.addEventListener("click", () => {
  const v = currentVar;
  rangesByVar[v] = JSON.parse(JSON.stringify(DEFAULT_RANGES[v]));
  setRangeUIForVar(v);
  showFrame().catch(console.error);
});

window.addEventListener("resize", () => {
  setControlsHeightCSSVar();
  showFrame().catch(()=>{});
});

/* ========================= INIT ========================= */
async function init() {
  setControlsHeightCSSVar();
  await loadIndex();
  setRangeUIForVar(currentVar);
  updateSliderUI();
  await showFrame();
}

init().catch(console.error);
</script>

</body>
</html>

