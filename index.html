<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LiveFish Edge – mbh</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-2.34.0.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050b10;
      color: #e0e6ee;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 8px 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      border-bottom: 1px solid #1b2836;
      background: #050b10;
    }
    header h1 {
      font-size: 16px;
      margin: 0;
      font-weight: 500;
    }
    header .region {
      font-size: 12px;
      opacity: 0.8;
    }
    #controls {
      padding: 8px 14px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      border-bottom: 1px solid #1b2836;
      background: #070d14;
      font-size: 13px;
    }
    label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    select,
    button {
      background: #0c1723;
      color: #e0e6ee;
      border: 1px solid #273649;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 13px;
    }
    button {
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    #timeline {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 200px;
    }
    #frame-slider {
      flex: 1;
      accent-color: #2fb3ff;
    }
    #frame-label {
      min-width: 180px;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    #plot {
      flex: 1;
      min-height: 0;
    }
  </style>
</head>
<body>
  <header>
    <h1>LiveFish Edge</h1>
    <span class="region">Region: mbh</span>
  </header>

  <div id="controls">
    <label>
      Variable:
      <select id="var-select">
        <option value="chl">Chlorophyll</option>
        <option value="sst">SST</option>
        <option value="uv">Currents</option>
      </select>
    </label>

    <div id="timeline">
      <button id="prev-btn">&#9664;</button>
      <button id="play-btn">Play</button>
      <button id="next-btn">&#9654;</button>
      <input id="frame-slider" type="range" min="0" max="0" step="1" value="0" />
      <span id="frame-label">No frames</span>
    </div>
  </div>

  <div id="plot"></div>

  <script>
    // ---------------------- CONFIG ----------------------
    const REGION_ID = "mbh";

    // Human-readable labels
    const VAR_LABELS = {
      chl: "Chlorophyll",
      sst: "SST",
      uv:  "Currents"
    };

    // Grid JSON names per variable (2-D lon/lat arrays)
    const VAR_TO_GRID = {
      chl: "viirs_chl_750_grid.json",
      sst: "goes_sst_1000_grid.json",
      uv:  "uv_12500_grid.json"
    };

    // ---------------------- STATE ----------------------
    let indexData = null;
    // Expect index.json to look like:
    // {
    //   "region_id": "mbh",
    //   "frames": {
    //      "chl": [ { "var": "chl", "path": "data/mbh/chl/xxx.json", "label": "..." }, ... ],
    //      "sst": [ ... ],
    //      "uv":  [ ... ]
    //   }
    // }
    let framesByVar = { chl: [], sst: [], uv: [] };

    let currentVar = "chl";
    let currentFrameIdx = 0;
    let playing = false;
    let playTimer = null;

    const gridCache = {}; // var -> { lon2d, lat2d, xAxis, yAxis, nx, ny }

    const plotDiv   = document.getElementById("plot");
    const varSelect = document.getElementById("var-select");
    const slider    = document.getElementById("frame-slider");
    const frameLbl  = document.getElementById("frame-label");
    const playBtn   = document.getElementById("play-btn");
    const prevBtn   = document.getElementById("prev-btn");
    const nextBtn   = document.getElementById("next-btn");

    // ---------------------- LOADERS ----------------------

    async function loadIndex() {
      const url = `data/${REGION_ID}/index.json`;
      const res = await fetch(url);
      if (!res.ok) {
        console.error("Failed to load index.json from", url);
        return;
      }
      indexData = await res.json();
      framesByVar = indexData.frames || framesByVar;

      // Set slider / UI for initial var
      setCurrentVar(currentVar);
    }

    async function loadGridForVar(v) {
      if (gridCache[v]) return gridCache[v];

      const gridName = VAR_TO_GRID[v];
      const candidates = [
        `data/${REGION_ID}/grids/${gridName}`,   // preferred
        `data/${REGION_ID}/${gridName}`,        // fallback
        gridName                                // last resort (root)
      ];

      let grid = null;
      for (const path of candidates) {
        try {
          const res = await fetch(path);
          if (res.ok) {
            grid = await res.json();
            break;
          }
        } catch (e) {
          // ignore and try next
        }
      }

      if (!grid) {
        console.error(`Could not load grid for variable "${v}" from`, candidates);
        throw new Error("Grid load failed");
      }

      let lon = grid.lon;
      let lat = grid.lat;

      if (!Array.isArray(lon) || !Array.isArray(lat)) {
        throw new Error("grid.lon / grid.lat are not arrays");
      }

      // Normalize to 2-D [ny][nx].
      // If they are already 2-D, keep. If 1-D flattened, reshape using ny, nx.
      if (!Array.isArray(lon[0])) {
        const nx = grid.nx;
        const ny = grid.ny;
        if (!Number.isInteger(nx) || !Number.isInteger(ny)) {
          throw new Error("Flattened grid arrays require nx, ny in JSON");
        }
        const flatLon = lon;
        const flatLat = lat;
        lon = [];
        lat = [];
        for (let j = 0; j < ny; j++) {
          lon.push(flatLon.slice(j * nx, (j + 1) * nx));
          lat.push(flatLat.slice(j * nx, (j + 1) * nx));
        }
      }

      const ny = lon.length;
      const nx = lon[0].length;

      const xAxis = lon[0].slice();                        // first row (constant lat)
      const yAxis = lon.map((_, j) => lat[j][0]);          // first column (constant lon)

      const result = { lon2d: lon, lat2d: lat, xAxis, yAxis, nx, ny };
      gridCache[v] = result;
      return result;
    }

    // Fetch a single frame JSON for current var.
    async function fetchFrameData(varKey, frameMeta) {
      // Expect frameMeta.path to be present; otherwise guess.
      let path = frameMeta.path || frameMeta.file || frameMeta.json || frameMeta.url;
      if (!path) {
        // Fallback: assume basename and put under data/mbh/{var}/
        const base = frameMeta.basename || frameMeta.name;
        path = `data/${REGION_ID}/${varKey}/${base}`;
      }
      // If path is not already rooted under data/, prepend region.
      if (!path.startsWith("data/")) {
        path = `data/${REGION_ID}/${path}`;
      }

      const res = await fetch(path);
      if (!res.ok) {
        console.error("Failed to load frame JSON from", path);
        throw new Error("Frame load failed");
      }
      const obj = await res.json();
      return obj;
    }

    // ---------------------- FIGURE BUILDERS ----------------------

    function frameTitleFromMeta(varKey, frameMeta, dataObj) {
      const label = frameMeta.label || frameMeta.timestamp || frameMeta.scan_id || "";
      const prettyVar = VAR_LABELS[varKey] || varKey;
      return `${prettyVar} – ${label}`;
    }

    function buildFigureForVar(varKey, gridInfo, dataObj, frameMeta) {
      const { lon2d, lat2d, xAxis, yAxis, nx, ny } = gridInfo;

      let z = null;
      let unitLabel = "";
      if (varKey === "chl") {
        z = dataObj.chl;
        unitLabel = dataObj.unit || "mg m⁻³";
      } else if (varKey === "sst") {
        z = dataObj.sst;
        unitLabel = dataObj.unit || "°C";
      } else if (varKey === "uv") {
        // Use speed for color; u/v optional for future quivers
        if (dataObj.data && dataObj.data.speed) {
          z = dataObj.data.speed;
        } else {
          z = dataObj.speed || null;
        }
        unitLabel = (dataObj.unit || "m s⁻¹");
      }

      if (!z) {
        throw new Error(`No data array found for var=${varKey}`);
      }

      // Expect z to be 2-D [ny][nx].
      // If it's flattened, reshape using ny,nx.
      if (!Array.isArray(z[0])) {
        const flat = z;
        const reshaped = [];
        let idx = 0;
        for (let j = 0; j < ny; j++) {
          const row = [];
          for (let i = 0; i < nx; i++) {
            row.push(flat[idx++]);
          }
          reshaped.push(row);
        }
        z = reshaped;
      }

      // Build customdata[ny][nx] = [lon, lat]
      const customdata = [];
      const text = [];
      for (let j = 0; j < ny; j++) {
        const rowCD = [];
        const rowText = [];
        for (let i = 0; i < nx; i++) {
          const lonVal = lon2d[j][i];
          const latVal = lat2d[j][i];
          rowCD.push([lonVal, latVal]);

          const val = z[j][i];
          let t = "";
          const numVal = (val === null || val === undefined || Number.isNaN(Number(val)))
            ? null
            : Number(val);
          if (numVal !== null && Number.isFinite(numVal)) {
            t = `<br>value=${numVal.toFixed(3)} ${unitLabel}`;
          }
          rowText.push(t);
        }
        customdata.push(rowCD);
        text.push(rowText);
      }

      const trace = {
        type: "heatmap",
        x: xAxis,
        y: yAxis,
        z: z,
        customdata: customdata,
        text: text,
        // Show lon/lat always; value only if text is non-empty
        hovertemplate: "lon=%{customdata[0]:.4f}<br>lat=%{customdata[1]:.4f}%{text}<extra></extra>",
        zauto: true,
        zsmooth: false,
        colorbar: {
          title: unitLabel
        }
      };

      const layout = {
        title: frameTitleFromMeta(varKey, frameMeta, dataObj),
        xaxis: {
          title: "Longitude",
          automargin: true
        },
        yaxis: {
          title: "Latitude",
          scaleanchor: "x",
          scaleratio: 1,
          automargin: true
        },
        margin: { l: 70, r: 10, t: 40, b: 60 },
        paper_bgcolor: "#050b10",
        plot_bgcolor: "#050b10",
        font: { color: "#e0e6ee" }
      };

      return { data: [trace], layout };
    }

    // ---------------------- UI / PLAYER ----------------------

    function updateSliderUI() {
      const frames = framesByVar[currentVar] || [];
      const n = frames.length;

      slider.min = 0;
      slider.max = Math.max(0, n - 1);
      slider.value = Math.min(currentFrameIdx, Math.max(0, n - 1));

      prevBtn.disabled = (n <= 1);
      nextBtn.disabled = (n <= 1);
      playBtn.disabled = (n <= 1);

      if (!n) {
        frameLbl.textContent = `${VAR_LABELS[currentVar] || currentVar}: no frames`;
      } else {
        const meta = frames[currentFrameIdx];
        const label = meta.label || meta.timestamp || `${currentFrameIdx + 1}/${n}`;
        frameLbl.textContent = `${VAR_LABELS[currentVar] || currentVar}: ${label}`;
      }
    }

    async function setCurrentVar(v) {
      currentVar = v;
      // Reset frame index if this var has fewer frames
      const frames = framesByVar[currentVar] || [];
      if (currentFrameIdx >= frames.length) currentFrameIdx = 0;
      updateSliderUI();
      if (frames.length) {
        await showFrame();
      } else {
        // Clear plot if no frames
        Plotly.purge(plotDiv);
      }
    }

    function stepFrame(delta) {
      const frames = framesByVar[currentVar] || [];
      const n = frames.length;
      if (!n) return;
      currentFrameIdx = (currentFrameIdx + delta + n) % n;
      slider.value = currentFrameIdx;
      showFrame();
    }

    function setPlaying(on) {
      if (on === playing) return;
      playing = on;
      playBtn.textContent = playing ? "Pause" : "Play";

      if (playing) {
        if (playTimer) clearInterval(playTimer);
        playTimer = setInterval(() => {
          stepFrame(+1);
        }, 800);  // 0.8 s per frame
      } else {
        if (playTimer) {
          clearInterval(playTimer);
          playTimer = null;
        }
      }
    }

    async function showFrame() {
      const frames = framesByVar[currentVar] || [];
      const n = frames.length;
      if (!n) return;

      const frameMeta = frames[currentFrameIdx];

      try {
        const [gridInfo, dataObj] = await Promise.all([
          loadGridForVar(currentVar),
          fetchFrameData(currentVar, frameMeta)
        ]);

        const fig = buildFigureForVar(currentVar, gridInfo, dataObj, frameMeta);
        await Plotly.react(plotDiv, fig.data, fig.layout, { responsive: true });

        updateSliderUI();
      } catch (err) {
        console.error("Error showing frame:", err);
      }
    }

    // ---------------------- EVENT HOOKS ----------------------

    varSelect.addEventListener("change", () => {
      setCurrentVar(varSelect.value);
    });

    slider.addEventListener("input", () => {
      currentFrameIdx = Number(slider.value) || 0;
      showFrame();
    });

    playBtn.addEventListener("click", () => {
      setPlaying(!playing);
    });

    prevBtn.addEventListener("click", () => {
      setPlaying(false);
      stepFrame(-1);
    });

    nextBtn.addEventListener("click", () => {
      setPlaying(false);
      stepFrame(+1);
    });

    // ---------------------- INIT ----------------------
    (async function init() {
      try {
        await loadIndex();
        // Ensure dropdown matches currentVar
        varSelect.value = currentVar;
      } catch (e) {
        console.error("Failed to initialize viewer:", e);
      }
    })();
  </script>
</body>
</html>

