<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LiveFish Edge</title>
  <link rel="icon" href="data:,">

  <script src="https://cdn.plot.ly/plotly-2.34.0.min.js"></script>

  <style>
    :root{
      --bg: #050b10;
      --fg: #e0e6ee;
      --panel: rgba(5, 11, 16, 0.92);
      --border: #1b2836;
      --ctrlH: 56px;
      --rangesH: 64px;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      overflow: auto;
    }

    /* Top controls */
    #controls {
      position: sticky;
      top: 0;
      z-index: 50;
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 8px 12px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(6px);
      flex-wrap: wrap;
    }

    #var-select {
      background: #0c1723;
      color: var(--fg);
      border: 1px solid #273649;
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 20px;
      font-weight: 750;
      min-height: 44px;
    }

    #timeline {
      flex: 1;
      display: flex;
      gap: 10px;
      align-items: center;
      min-width: 320px;
      flex-wrap: wrap;
    }

    button {
      background: #0c1723;
      color: var(--fg);
      border: 1px solid #273649;
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 16px;
      cursor: pointer;
      min-height: 44px; /* mobile tap target */
    }
    button:disabled { opacity: 0.45; cursor: default; }

    #frame-slider {
      flex: 1;
      min-width: 220px;
      height: 24px;
    }

    #frame-label {
      min-width: 220px;
      text-align: right;
      font-size: 20px;
      font-weight: 750;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    /* Plot area */
    #plot-wrap {
      position: relative;
      width: 100%;
    }

    #plot {
      width: 100%;
      /* use dvh for mobile browser UI */
      height: calc(100dvh - var(--ctrlH) - var(--rangesH));
      min-height: 520px;
      /* Important for touch devices:
         - allow page scroll vertically
         - allow pinch zoom inside plot
      */
      touch-action: pan-y pinch-zoom;
    }

    /* Bottom range controls */
    #ranges {
      position: sticky;
      bottom: 0;
      z-index: 40;
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      background: var(--panel);
      border-top: 1px solid var(--border);
      backdrop-filter: blur(6px);
      font-size: 14px;
      flex-wrap: wrap;
    }

    .range-block {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: rgba(12, 23, 35, 0.65);
      flex-wrap: wrap;
    }

    .range-block .name {
      font-weight: 800;
      margin-right: 2px;
    }

    input[type="number"] {
      width: 110px;
      background: #0c1723;
      color: var(--fg);
      border: 1px solid #273649;
      border-radius: 10px;
      padding: 10px 10px;
      font-size: 16px;
      min-height: 44px; /* mobile tap target */
    }

    /* Floating UI overlay (always visible) */
    #floating-ui {
      position: fixed;
      top: calc(var(--ctrlH) + 6px);
      left: 0;
      right: 0;
      z-index: 200;
      pointer-events: none; /* let touches go to plot */
    }

    /* Floating modebar host (upper-left) */
    #modebar-host {
      position: fixed;
      top: calc(var(--ctrlH) + 10px);
      left: 10px;
      z-index: 210;
      pointer-events: auto; /* allow clicking buttons */
    }

    /* Floating readout (upper-right) */
    #readout {
      position: fixed;
      top: calc(var(--ctrlH) + 10px);
      right: 12px;
      z-index: 210;
      padding: 8px 10px;
      background: rgba(255,255,255,0.60);
      color: #000;
      border: 1px solid rgba(0,0,0,0.12);
      border-radius: 12px;
      font-variant-numeric: tabular-nums;
      pointer-events: none;
      white-space: nowrap;
      min-width: 170px;
      text-align: right;
    }

    /* Make Plotly modebar fit the floating host nicely */
    .modebar {
      background: rgba(5, 11, 16, 0.65) !important;
      border-radius: 12px !important;
      padding: 6px 6px !important;
    }

    /* Mobile layout tweaks */
    @media (max-width: 820px) {
      :root{ --ctrlH: 72px; --rangesH: 92px; }
      #frame-label { text-align: left; min-width: 0; width: 100%; }
      #timeline { min-width: 0; width: 100%; }
      #frame-slider { min-width: 0; width: 100%; }
      #var-select { font-size: 18px; }
      #readout {
        right: 10px;
        min-width: 140px;
        font-size: 14px;
      }
    }
  </style>
</head>

<body>
  <div id="controls">
    <select id="var-select">
      <option value="chl">Chlorophyll</option>
      <option value="sst">Temperature</option>
      <option value="uv">Currents</option>
    </select>

    <div id="timeline">
      <button id="prev-btn">&#9664;</button>
      <button id="play-btn">Play</button>
      <button id="next-btn">&#9654;</button>
      <input id="frame-slider" type="range" min="0" max="0" step="1" value="0" />
      <span id="frame-label"></span>
    </div>
  </div>

  <!-- floating overlay -->
  <div id="floating-ui">
    <div id="modebar-host"></div>
    <div id="readout"></div>
  </div>

  <div id="plot-wrap">
    <div id="plot"></div>
  </div>

  <div id="ranges">
    <div class="range-block">
      <span class="name" id="range-title">Range</span>
      <span>vmin</span><input id="vmin-input" type="number" step="any" inputmode="decimal" />
      <span>vmax</span><input id="vmax-input" type="number" step="any" inputmode="decimal" />
      <button id="apply-range">Apply</button>
      <button id="reset-range">Reset</button>
    </div>
    <div style="opacity:0.8">
      Note: CHL inputs are linear (mg/m³). Viewer internally colors log10.
    </div>
  </div>

<script>
/* ========================= CONFIG ========================= */
const REGION_ID = "mbh";

const VAR_LABELS = { chl: "Chlorophyll", sst: "Temperature", uv: "Currents" };

const VAR_TO_GRID = {
  chl: "viirs_chl_750_grid.json",
  sst: "goes_sst_1000_grid.json",
  uv:  "uv_12500_grid.json"
};

const INDEX_CANDIDATES = [
  "index.json",
  "data/index.json",
  `data/${REGION_ID}/index.json`
];

const DEFAULT_RANGES = {
  chl: { vmin: 0.01, vmax: 10.0, unit: "mg/m³" },
  sst: { vmin: 23.0, vmax: 28.0, unit: "°C" },
  uv:  { vmin: 0.0,  vmax: 2.0,  unit: "m/s" }
};

let userRanges = {
  chl: { ...DEFAULT_RANGES.chl },
  sst: { ...DEFAULT_RANGES.sst },
  uv:  { ...DEFAULT_RANGES.uv }
};

/* chlorophyll colorscale (nice algae-like) */
const CHL_ALGAE = [
  [0.00, "#081d38"],
  [0.10, "#1d4f91"],
  [0.22, "#00a6ca"],
  [0.36, "#00d17f"],
  [0.52, "#a3f700"],
  [0.70, "#ffe600"],
  [0.86, "#ff7a00"],
  [1.00, "#b30000"]
];

/* chlorophyll tick labels (show only 0.01, 0.1, 1, 10) */
const CHL_TICKS_LINEAR = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10];
const CHL_TICKVALS = CHL_TICKS_LINEAR.map(v => Math.log10(v));
const CHL_TICKTEXT = CHL_TICKS_LINEAR.map(v => (v===0.01||v===0.1||v===1||v===10) ? String(v) : "");

/* Currents arrow styling */
const CURRENT_ARROW_STEP_MAXPTS = 50 * 50;
const CURRENT_ARROW_SCALE = 1;

/* ========================= STATE ========================= */
let framesByVar = { chl: [], sst: [], uv: [] };
let frameTimesByVar = { chl: [], sst: [], uv: [] }; // epoch ms
let currentVar = "chl";
let currentFrameIdx = 0;
let playing = false;
let playTimer = null;

const gridCache = {};
let _readoutHooked = false;
let _relayoutHooked = false;

let viewState = { hasRange:false, xRange:null, yRange:null, autorange:true };

/* Touch detection */
const IS_TOUCH = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;

/* ========================= DOM ========================= */
const plotDiv   = document.getElementById("plot");
const varSelect = document.getElementById("var-select");
const slider    = document.getElementById("frame-slider");
const frameLbl  = document.getElementById("frame-label");
const playBtn   = document.getElementById("play-btn");
const prevBtn   = document.getElementById("prev-btn");
const nextBtn   = document.getElementById("next-btn");
const readoutDiv = document.getElementById("readout");
const modebarHost = document.getElementById("modebar-host");

const rangeTitle = document.getElementById("range-title");
const vminInput = document.getElementById("vmin-input");
const vmaxInput = document.getElementById("vmax-input");
const applyBtn = document.getElementById("apply-range");
const resetBtn = document.getElementById("reset-range");

function setReadout(txt) { readoutDiv.textContent = txt || ""; }

/* ========================= TIME PARSERS ========================= */
function parseChlUtcFromName(filename) {
  const m = filename.match(/_(\d{4})(\d{3})\.(\d{4})_/);
  if (!m) return null;
  const year = Number(m[1]);
  const jjj  = Number(m[2]);
  const hhmm = m[3];
  const hh = Number(hhmm.slice(0, 2));
  const mm = Number(hhmm.slice(2, 4));
  const d0 = new Date(Date.UTC(year, 0, 1, 0, 0, 0));
  return new Date(d0.getTime() + (jjj - 1) * 86400e3 + hh * 3600e3 + mm * 60e3);
}

function parseSstUtcFromName(filename) {
  const m = filename.match(/sst_.*?_(\d{4})(\d{3})_(\d{8})_(\d{2})_/);
  if (!m) return null;
  const year = Number(m[1]);
  const jjj  = Number(m[2]);
  const hh   = Number(m[4]);
  const d0 = new Date(Date.UTC(year, 0, 1, 0, 0, 0));
  return new Date(d0.getTime() + (jjj - 1) * 86400e3 + hh * 3600e3);
}

function parseUvDateFromName(filename) {
  const m = filename.match(/_(\d{8})_/);
  if (!m) return null;
  const y = Number(m[1].slice(0, 4));
  const mo = Number(m[1].slice(4, 6)) - 1;
  const d = Number(m[1].slice(6, 8));
  return new Date(Date.UTC(y, mo, d));
}

function fmtLocalDateTime(dt) {
  return dt.toLocaleString(undefined, {
    year: "numeric", month: "2-digit", day: "2-digit",
    hour: "2-digit", minute: "2-digit",
    hour12: false
  });
}
function fmtLocalDate(dt) {
  return dt.toLocaleDateString(undefined, {
    year: "numeric", month: "2-digit", day: "2-digit"
  });
}

function timeOnlyLabel(varKey, frameMeta) {
  const path = framePathOf(frameMeta);
  const filename = String(path).split("/").pop() || "";
  if (varKey === "chl") { const dt = parseChlUtcFromName(filename); return dt ? fmtLocalDateTime(dt) : ""; }
  if (varKey === "sst") { const dt = parseSstUtcFromName(filename); return dt ? fmtLocalDateTime(dt) : ""; }
  if (varKey === "uv")  { const dt = parseUvDateFromName(filename);  return dt ? fmtLocalDate(dt) : ""; }
  return "";
}

function epochMsForFrame(varKey, frameMeta) {
  const path = framePathOf(frameMeta);
  const filename = String(path).split("/").pop() || "";
  let dt = null;
  if (varKey === "chl") dt = parseChlUtcFromName(filename);
  if (varKey === "sst") dt = parseSstUtcFromName(filename);
  if (varKey === "uv")  dt = parseUvDateFromName(filename);
  return dt ? dt.getTime() : null;
}

/* ========================= HELPERS ========================= */
function is2D(a) { return Array.isArray(a) && a.length > 0 && Array.isArray(a[0]) && a[0].length > 0; }
function framePathOf(f) { return String(f?.json_path || f?.path || f?.file || f?.url || f?.json || ""); }
function frameFilenameOf(f) { const p = framePathOf(f); return p.split("/").pop() || p; }

function filterFramesForVar(varKey, frames) {
  const out = [];
  for (const f of (frames || [])) {
    const fn = frameFilenameOf(f).toLowerCase();
    if (!fn.endsWith(".json")) continue;
    if (fn.includes("grid")) continue;
    if (varKey === "chl" && !fn.includes("_chl_")) continue;
    if (varKey === "sst" && !fn.startsWith("sst_")) continue;
    if (varKey === "uv"  && !fn.startsWith("uv_")) continue;
    out.push(f);
  }
  return out;
}

function closestIndex(times, targetMs) {
  if (!times.length || targetMs === null) return 0;
  let best = 0;
  let bestDist = Infinity;
  for (let i = 0; i < times.length; i++) {
    const t = times[i];
    if (t === null) continue;
    const d = Math.abs(t - targetMs);
    if (d < bestDist) { bestDist = d; best = i; }
  }
  return best;
}

/* ========================= VIEW SYNC ========================= */
function attachRelayoutListenerOnce() {
  if (_relayoutHooked) return;
  _relayoutHooked = true;

  plotDiv.on("plotly_relayout", (ev) => {
    if (!ev) return;
    const xr0 = ev["xaxis.range[0]"], xr1 = ev["xaxis.range[1]"];
    const yr0 = ev["yaxis.range[0]"], yr1 = ev["yaxis.range[1]"];
    if (xr0 !== undefined && xr1 !== undefined && yr0 !== undefined && yr1 !== undefined) {
      viewState.hasRange = true;
      viewState.autorange = false;
      viewState.xRange = [xr0, xr1];
      viewState.yRange = [yr0, yr1];
      return;
    }
    if (ev["xaxis.autorange"] === true || ev["yaxis.autorange"] === true) {
      viewState.hasRange = false;
      viewState.autorange = true;
      viewState.xRange = null;
      viewState.yRange = null;
    }
  });
}

/* ========================= STABLE LAYOUT ========================= */
function stableLayout() {
  const layout = {
    uirevision: "sync_fov_v3",
    margin: { l: 52, r: 92, t: 10, b: 40 },
    paper_bgcolor: "#050b10",
    plot_bgcolor: "#050b10",
    font: { color: "#e0e6ee" },
    xaxis: { title: "Longitude", automargin: true },
    yaxis: { title: "Latitude", automargin: true, scaleanchor: "x", scaleratio: 1 },
    hovermode: "closest",
  };

  if (viewState.hasRange && viewState.xRange && viewState.yRange) {
    layout.xaxis.range = viewState.xRange;
    layout.yaxis.range = viewState.yRange;
    layout.xaxis.autorange = false;
    layout.yaxis.autorange = false;
  } else {
    layout.xaxis.autorange = true;
    layout.yaxis.autorange = true;
  }
  return layout;
}

/* ========================= FIGURES ========================= */
function buildChl(gridInfo, dataObj) {
  const { xAxis, yAxis, nx, ny } = gridInfo;
  if (!is2D(dataObj.chl)) throw new Error("CHL JSON missing 2-D key: chl");

  const vmin = userRanges.chl.vmin;
  const vmax = userRanges.chl.vmax;
  const zmin = Math.log10(vmin);
  const zmax = Math.log10(vmax);

  const z = Array.from({ length: ny }, () => Array(nx).fill(null));
  const cd = Array.from({ length: ny }, () => Array(nx).fill(null));

  for (let j = 0; j < ny; j++) {
    for (let i = 0; i < nx; i++) {
      const vv = dataObj.chl[j][i];
      const num = (vv === null || vv === undefined || !isFinite(vv)) ? null : Number(vv);
      cd[j][i] = num;
      z[j][i] = (num !== null && num > 0) ? Math.log10(num) : null;
    }
  }

  return {
    data: [{
      type: "heatmap",
      x: xAxis, y: yAxis,
      z,
      customdata: cd,
      hoverinfo: "none",
      zauto: false,
      zmin, zmax,
      colorscale: CHL_ALGAE,
      colorbar: {
        title: { text: DEFAULT_RANGES.chl.unit, side: "top" },
        x: 1.02, xanchor: "left", len: 0.92,
        tickmode: "array",
        tickvals: CHL_TICKVALS,
        ticktext: CHL_TICKTEXT,
        ticks: "outside"
      },
      zsmooth: false
    }],
    layout: stableLayout()
  };
}

function buildSst(gridInfo, dataObj) {
  const { xAxis, yAxis } = gridInfo;
  if (!is2D(dataObj.sst)) throw new Error("SST JSON missing 2-D key: sst");

  const vmin = userRanges.sst.vmin;
  const vmax = userRanges.sst.vmax;

  return {
    data: [{
      type: "heatmap",
      x: xAxis, y: yAxis,
      z: dataObj.sst,
      customdata: dataObj.sst,
      hoverinfo: "none",
      zauto: false,
      zmin: vmin, zmax: vmax,
      colorscale: "RdBu", /* blue cold, red warm */
      reversescale: true,
      colorbar: {
        title: { text: DEFAULT_RANGES.sst.unit, side: "top" },
        x: 1.02, xanchor: "left", len: 0.92
      },
      zsmooth: false
    }],
    layout: stableLayout()
  };
}

function buildUv(gridInfo, dataObj) {
  const { xAxis, yAxis, nx, ny } = gridInfo;
  const d = dataObj.data || dataObj;

  if (!d || !is2D(d.u) || !is2D(d.v) || !is2D(d.speed)) {
    throw new Error("UV JSON missing 2-D keys: data.u, data.v, data.speed");
  }

  const speed = d.speed;
  const u = d.u, v = d.v;

  const vmin = userRanges.uv.vmin;
  const vmax = userRanges.uv.vmax;

  // background heatmap (speed placeholder)
  const cd = Array.from({ length: ny }, () => Array(nx).fill(null));
  for (let j = 0; j < ny; j++) {
    for (let i = 0; i < nx; i++) {
      const sp = speed[j][i];
      cd[j][i] = (sp === null || sp === undefined || !isFinite(sp)) ? null : Number(sp);
    }
  }

  const bg = {
    type: "heatmap",
    x: xAxis, y: yAxis,
    z: speed,
    customdata: cd,
    hoverinfo: "none",
    zauto: false,
    zmin: vmin,
    zmax: vmax,
    colorscale: "Viridis",
    colorbar: {
      title: { text: DEFAULT_RANGES.uv.unit, side: "top" },
      x: 1.02, xanchor: "left", len: 0.92
    },
    zsmooth: false
  };

  // open arrowheads that scale with zoom (lon/lat units)
  const lineX = [];
  const lineY = [];

  let step = 1;
  if (nx * ny > CURRENT_ARROW_STEP_MAXPTS) step = 2;

  // grid spacing => visible head length
  let dxg = 0.01, dyg = 0.01;
  if (nx > 1) dxg = Math.abs(xAxis[1] - xAxis[0]);
  if (ny > 1) dyg = Math.abs(yAxis[1] - yAxis[0]);
  const minHead = 0.65 * Math.max(dxg, dyg);
  const headFrac = 0.42;
  const headAngle = (12 * Math.PI) / 180;

  for (let j = 0; j < ny; j += step) {
    const lat0 = yAxis[j];
    for (let i = 0; i < nx; i += step) {
      const lon0 = xAxis[i];
      const uu = u[j][i];
      const vv = v[j][i];
      const sp = speed[j][i];
      if (!isFinite(uu) || !isFinite(vv) || !isFinite(sp)) continue;

      const lon1 = lon0 + uu * CURRENT_ARROW_SCALE;
      const lat1 = lat0 + vv * CURRENT_ARROW_SCALE;

      const dx = lon1 - lon0;
      const dy = lat1 - lat0;
      const L = Math.hypot(dx, dy);
      if (!(L > 0)) continue;

      // shaft
      lineX.push(lon0, lon1, null);
      lineY.push(lat0, lat1, null);

      // open "V" head
      const theta = Math.atan2(dy, dx);
      const hl = Math.max(minHead, headFrac * L);

      const xL = lon1 + hl * Math.cos(theta + Math.PI - headAngle);
      const yL = lat1 + hl * Math.sin(theta + Math.PI - headAngle);
      const xR = lon1 + hl * Math.cos(theta + Math.PI + headAngle);
      const yR = lat1 + hl * Math.sin(theta + Math.PI + headAngle);

      lineX.push(lon1, xL, null, lon1, xR, null);
      lineY.push(lat1, yL, null, lat1, yR, null);
    }
  }

  const arrows = {
    type: "scatter",
    mode: "lines",
    x: lineX, y: lineY,
    hoverinfo: "none",
    line: { color: "#000000", width: 1.6 },
    showlegend: false
  };

  return { data: [bg, arrows], layout: stableLayout() };
}

function buildForVar(varKey, gridInfo, dataObj) {
  if (varKey === "chl") return buildChl(gridInfo, dataObj);
  if (varKey === "sst") return buildSst(gridInfo, dataObj);
  if (varKey === "uv")  return buildUv(gridInfo, dataObj);
  throw new Error(`Unsupported varKey=${varKey}`);
}

/* ========================= READOUT (hover + tap) ========================= */
function setupReadoutHandlersOnce() {
  if (_readoutHooked) return;
  _readoutHooked = true;

  // Desktop hover
  plotDiv.on("plotly_unhover", () => { if (!IS_TOUCH) setReadout(""); });

  plotDiv.on("plotly_hover", (ev) => {
    if (IS_TOUCH) return; // avoid fighting touch
    const p = ev.points && ev.points[0];
    if (!p) return;
    renderReadoutFromPoint(p);
  });

  // Mobile tap
  plotDiv.on("plotly_click", (ev) => {
    const p = ev.points && ev.points[0];
    if (!p) return;
    renderReadoutFromPoint(p);
  });
}

function renderReadoutFromPoint(p) {
  const lon = Number(p.x);
  const lat = Number(p.y);
  if (!isFinite(lon) || !isFinite(lat)) return;

  const base = `${lon.toFixed(3)} ${lat.toFixed(3)}`;
  const cd = p.customdata;

  if (cd === null || cd === undefined || !isFinite(cd)) { setReadout(base); return; }

  const val = Number(cd);
  if (currentVar === "sst") setReadout(`${base} ${val.toFixed(2)}`);
  else setReadout(`${base} ${val.toFixed(3)}`);
}

/* Keep modebar floating even when page scrolls */
function floatModebarOnceReady() {
  const mb = plotDiv.querySelector(".modebar");
  if (!mb) return;
  if (mb.parentElement === modebarHost) return;
  modebarHost.appendChild(mb);
}

/* ========================= UI ========================= */
function syncRangeInputsToVar() {
  const r = userRanges[currentVar];
  rangeTitle.textContent = `${VAR_LABELS[currentVar]} range`;
  vminInput.value = r.vmin;
  vmaxInput.value = r.vmax;
}

function updateSliderUI() {
  const frames = framesByVar[currentVar] || [];
  const n = frames.length;

  slider.min = 0;
  slider.max = Math.max(0, n - 1);
  slider.value = Math.min(currentFrameIdx, Math.max(0, n - 1));

  prevBtn.disabled = n <= 1;
  nextBtn.disabled = n <= 1;
  playBtn.disabled = n <= 1;

  frameLbl.textContent = n ? timeOnlyLabel(currentVar, frames[currentFrameIdx]) : "";
}

/* switch vars => jump to closest time */
async function setCurrentVar(v, keepTime = true) {
  const prevVar = currentVar;
  const prevFrames = framesByVar[prevVar] || [];
  const prevFrame = prevFrames[currentFrameIdx] || null;
  const prevT = (keepTime && prevFrame) ? epochMsForFrame(prevVar, prevFrame) : null;

  currentVar = v;
  varSelect.value = v;

  const frames = framesByVar[currentVar] || [];
  const times = frameTimesByVar[currentVar] || [];

  if (frames.length) {
    currentFrameIdx = (keepTime && prevT !== null) ? closestIndex(times, prevT) : 0;
  } else {
    currentFrameIdx = 0;
  }

  syncRangeInputsToVar();
  updateSliderUI();

  if (frames.length) await showFrame();
  else Plotly.purge(plotDiv);
}

function stepFrame(delta) {
  const frames = framesByVar[currentVar] || [];
  const n = frames.length;
  if (!n) return;
  currentFrameIdx = (currentFrameIdx + delta + n) % n;
  slider.value = currentFrameIdx;
  showFrame();
}

function setPlaying(on) {
  if (on === playing) return;
  playing = on;
  playBtn.textContent = playing ? "Pause" : "Play";
  if (playing) {
    if (playTimer) clearInterval(playTimer);
    playTimer = setInterval(() => stepFrame(+1), 800);
  } else {
    if (playTimer) clearInterval(playTimer);
    playTimer = null;
  }
}

/* ========================= LOADING ========================= */
async function loadIndex() {
  let idx = null;
  for (const url of INDEX_CANDIDATES) {
    try {
      const res = await fetch(url);
      if (res.ok) { idx = await res.json(); break; }
    } catch (_) {}
  }
  if (!idx) throw new Error("Failed to load index.json");

  const fbv = idx.frames || idx.framesByVar || idx.frames_by_var || framesByVar;
  framesByVar = {
    chl: filterFramesForVar("chl", fbv.chl || []),
    sst: filterFramesForVar("sst", fbv.sst || []),
    uv:  filterFramesForVar("uv",  fbv.uv  || [])
  };

  for (const v of Object.keys(framesByVar)) {
    framesByVar[v].sort((a, b) => {
      const ta = epochMsForFrame(v, a) ?? 0;
      const tb = epochMsForFrame(v, b) ?? 0;
      return ta - tb;
    });
    frameTimesByVar[v] = framesByVar[v].map(f => epochMsForFrame(v, f));
  }

  await setCurrentVar(currentVar, false);
}

async function loadGridForVar(v) {
  if (gridCache[v]) return gridCache[v];
  const gridName = VAR_TO_GRID[v];
  const url = `data/${REGION_ID}/grids/${gridName}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Could not load grid for ${v}: ${url}`);
  const grid = await res.json();

  const lon = grid.lon, lat = grid.lat;
  if (!Array.isArray(lon) || !Array.isArray(lat) || !Array.isArray(lon[0]) || !Array.isArray(lat[0])) {
    throw new Error("Grid JSON must contain 2-D lon/lat arrays");
  }

  const ny = lon.length;
  const nx = lon[0].length;
  const xAxis = lon[0].slice();
  const yAxis = lat.map(r => r[0]);

  const info = { xAxis, yAxis, nx, ny };
  gridCache[v] = info;
  return info;
}

async function fetchFrameData(varKey, frameMeta) {
  const p = framePathOf(frameMeta);
  if (!p) throw new Error("Frame has no json path");
  const url = p.startsWith("data/") ? p : `data/${REGION_ID}/${varKey}/${p}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Frame load failed: ${url}`);
  return await res.json();
}

/* ========================= RENDER ========================= */
async function showFrame() {
  const frames = framesByVar[currentVar] || [];
  if (!frames.length) return;

  const frameMeta = frames[currentFrameIdx];

  const [gridInfo, dataObj] = await Promise.all([
    loadGridForVar(currentVar),
    fetchFrameData(currentVar, frameMeta)
  ]);

  const fig = buildForVar(currentVar, gridInfo, dataObj);

  await Plotly.react(plotDiv, fig.data, fig.layout, {
    responsive: true,
    displayModeBar: true,
    scrollZoom: true,      // pinch zoom on mobile
    doubleClick: "reset",  // double tap/click resets
  });

  // float modebar and keep it floating across renders
  floatModebarOnceReady();
  setTimeout(floatModebarOnceReady, 0);

  setupReadoutHandlersOnce();
  attachRelayoutListenerOnce();
  updateSliderUI();
}

/* ========================= EVENTS ========================= */
varSelect.addEventListener("change", () => {
  setPlaying(false);
  setCurrentVar(varSelect.value, true);
});

slider.addEventListener("input", () => {
  currentFrameIdx = Number(slider.value) || 0;
  showFrame();
});

playBtn.addEventListener("click", () => setPlaying(!playing));
prevBtn.addEventListener("click", () => { setPlaying(false); stepFrame(-1); });
nextBtn.addEventListener("click", () => { setPlaying(false); stepFrame(+1); });

applyBtn.addEventListener("click", () => {
  const vmin = Number(vminInput.value);
  const vmax = Number(vmaxInput.value);
  if (!isFinite(vmin) || !isFinite(vmax) || vmax <= vmin) return;
  userRanges[currentVar].vmin = vmin;
  userRanges[currentVar].vmax = vmax;
  showFrame();
});

resetBtn.addEventListener("click", () => {
  userRanges[currentVar] = { ...DEFAULT_RANGES[currentVar] };
  syncRangeInputsToVar();
  showFrame();
});

/* Keep plot sized on rotate */
window.addEventListener("resize", () => { try { Plotly.Plots.resize(plotDiv); } catch(_){} });

/* ========================= INIT ========================= */
(async function init() {
  try {
    await loadIndex();
    syncRangeInputsToVar();
  } catch (e) {
    console.error("Init failed:", e);
  }
})();
</script>

</body>
</html>

